#!/bin/bash

assert_command_exists realpath

function git_get_code_roots() {

    local KEY

    CODE_ROOTS=()

    if [ "${#ORIGINAL_ARGUMENTS[@]}" -gt "0" ]; then

        CODE_ROOTS=("${ORIGINAL_ARGUMENTS[@]}")

    elif [ "${#DEFAULT_CODE_ROOTS[@]}" -gt "0" ]; then

        CODE_ROOTS=("${DEFAULT_CODE_ROOTS[@]}")

    fi

    for KEY in "${!CODE_ROOTS[@]}"; do

        [ -d "${CODE_ROOTS[$KEY]}" ] || unset "CODE_ROOTS[$KEY]"

        CODE_ROOTS[$KEY]="$(realpath "${CODE_ROOTS[$KEY]}")"

    done

}

function git_is_dir_working_root() {

    local ROOT_PATH="$1" IN_WORK_TREE SUPERPROJECT TOPLEVEL

    [ -d "$1" ] || die "Error: $1 is not a directory"

    ROOT_PATH="$(realpath "$ROOT_PATH")"

    pushd "$1" >/dev/null || die

    # 1. repo directory? (exits non-zero with error output otherwise)
    # 2. *working* repo directory? (i.e. not bare or inside .git)
    IN_WORK_TREE="$(git rev-parse --is-inside-work-tree 2>/dev/null || echo "false")"
    [ "$IN_WORK_TREE" = "true" ] || pop_return1

    # 3. not a submodule?
    SUPERPROJECT="$(git rev-parse --show-superproject-working-tree)" || die
    [ -z "$SUPERPROJECT" ] || pop_return1

    # 4. top-level directory?
    TOPLEVEL="$(git rev-parse --show-toplevel)" || die

    popd >/dev/null

    [ "$TOPLEVEL" = "$ROOT_PATH" ]

}

function git_format_remotes() {

    local REMOTE REMOTE_URL REMOTES=()

    for REMOTE in "$@"; do

        REMOTE_URL="$(git remote get-url "$REMOTE")"
        [ -z "$REMOTE_URL" ] || REMOTE_URL="($REMOTE_URL)"
        REMOTES+=("${BOLD}${REMOTE}${RESET}${REMOTE_URL}")

    done

    echo "${NO_WRAP}${REMOTES[*]}${WRAP}"

}

# Usage: git_format_branch "branch_name" [commits behind] [commits ahead]
function git_format_branch() {

    local BRANCH BRANCH_EXTRA=()

    BRANCH="${BOLD}${1}${RESET}"

    [ "${2:-0}" -eq "0" ] || BRANCH_EXTRA+=("behind $2")
    [ "${3:-0}" -eq "0" ] || BRANCH_EXTRA+=("ahead $3")
    [ "${#BRANCH_EXTRA[@]}" -eq "0" ] || BRANCH="${BRANCH}[$(array_join_by "," "${BRANCH_EXTRA[@]}")]"

    echo "$BRANCH"

}

function git_add_global_ignore() {

    local i IGNORE_FILE

    IGNORE_FILE="$(git config --global core.excludesFile)" || die "Error: Git global option core.excludesFile not defined"
    IGNORE_FILE="${IGNORE_FILE/#\~/$HOME}"

    [ -f "$IGNORE_FILE" ] || touch "$IGNORE_FILE" || die

    [ -f "$IGNORE_FILE" ] || die "Error: unable to create file $IGNORE_FILE"

    for i in "$@"; do

        if ! grep -q '^'"$(sed_escape_search "$i" N)"'$' "$IGNORE_FILE"; then

            echo "$i" >>"$IGNORE_FILE"

        fi

    done

}

# Usage: git_add_global_setting <setting.name> <value> [change if already set? (y/N)]
function git_add_global_setting() {

    if [ "${3:-N}" = "Y" ] || ! git config --global "$1" >/dev/null 2>&1; then

        local EXTRA=(--global)

        if is_bool "$1"; then

            EXTRA+=("--bool")

        elif is_int "$1"; then

            EXTRA+=("--int")

        fi

        git config "${EXTRA[@]}" "$1" "$2"

    fi

}

function dev_apply_system_config() {

    dir_make_and_own "/usr/local/bin"

    if command_exists git; then

        file_to_array "$CONFIG_DIR/gitignore" '^[[:space:]]*$' '^#'

        if [ "${#FILE_TO_ARRAY[@]}" -gt "0" ]; then

            # shellcheck disable=SC2088
            git_add_global_setting core.excludesFile "~/.gitignore"
            git_add_global_ignore "${FILE_TO_ARRAY[@]}"

        fi

        git_add_global_setting push.default simple

        local MERGETOOL=

        command_exists meld && MERGETOOL=meld || true

        if [ -n "$MERGETOOL" ]; then

            git_add_global_setting merge.guitool "$MERGETOOL" Y
            git_add_global_setting mergetool.prompt false

        fi

    fi

    local SUDO_OR_NOT=

    # on macOS, global pip and npm management doesn't require sudo (courtesy of Homebrew)
    if [ "$IS_MACOS" -ne "1" ]; then

        SUDO_OR_NOT="sudo -H "

    fi

    if command_exists pip; then

        local PIP_REQUIRED=()

        file_to_array "$CONFIG_DIR/pip-packages" '^[[:space:]]*$' '^#'

        if [ "${#FILE_TO_ARRAY[@]}" -gt "0" ]; then

            PIP_REQUIRED+=("${FILE_TO_ARRAY[@]}")

        fi

        if [ "${#PIP_REQUIRED[@]}" -gt "0" ]; then

            install_or_queue "pip" "${PIP_REQUIRED[*]}" Y package packages "${SUDO_OR_NOT}pip list --format freeze 2>/dev/null | gnu_grep -Po '^[a-zA-Z0-9-]+'" "" "${SUDO_OR_NOT}pip install"

        fi

    fi

    if command_exists pip3; then

        local PIP3_REQUIRED=()

        file_to_array "$CONFIG_DIR/pip3-packages" '^[[:space:]]*$' '^#'

        if [ "${#FILE_TO_ARRAY[@]}" -gt "0" ]; then

            PIP3_REQUIRED+=("${FILE_TO_ARRAY[@]}")

        fi

        if [ "${#PIP3_REQUIRED[@]}" -gt "0" ]; then

            install_or_queue "pip3" "${PIP3_REQUIRED[*]}" Y package packages "${SUDO_OR_NOT}pip3 list --format freeze 2>/dev/null | gnu_grep -Po '^[a-zA-Z0-9-]+'" "" "${SUDO_OR_NOT}pip3 install"

        fi

    fi

    if command_exists npm; then

        function npm_install() {

            [ -e "/usr/bin/python2" ] && eval "${SUDO_OR_NOT}npm config -g set python /usr/bin/python2" || true

            local PACKAGE

            for PACKAGE in "$@"; do

                eval "${SUDO_OR_NOT}npm install -g" "$PACKAGE" || eval "${SUDO_OR_NOT}npm install -g --unsafe-perm" "$PACKAGE"

            done

        }

        local NPM_REQUIRED=()

        [ "$IS_MACOS" -eq "1" ] && NPM_REQUIRED+=(yarn) || true

        file_to_array "$CONFIG_DIR/npm-packages" '^[[:space:]]*$' '^#'

        if [ "${#FILE_TO_ARRAY[@]}" -gt "0" ]; then

            NPM_REQUIRED+=("${FILE_TO_ARRAY[@]}")

        fi

        if [ "${#NPM_REQUIRED[@]}" -gt "0" ]; then

            install_or_queue "npm" "${NPM_REQUIRED[*]}" Y package packages "${SUDO_OR_NOT}npm list -g --depth=0 --parseable | tail -n +2 | gnu_grep -Po '(?<=/)[^/]*$'" "" "npm_install"

        fi

    fi

    if command_exists php; then

        local INI_ROOT COMPOSER_REQUIRED

        for INI_ROOT in /etc/php /usr/local/etc/php; do

            [ -d "$INI_ROOT" ] && php_apply_developer_settings "$INI_ROOT" || true

        done

        dir_make_and_own "/usr/local/lib/composer"

        mkdir -p "$LOCAL_DIR/composer"

        pushd "$LOCAL_DIR/composer" >/dev/null || die

        if [ ! -e "composer.phar" ]; then

            "$ROOT_DIR/bash/composer-install.sh" || die

        fi

        if [ ! -e "composer.json" ]; then

            cat <<EOF >"composer.json"
{
    "config": {
        "vendor-dir": "/usr/local/lib/composer",
        "bin-dir": "/usr/local/bin"
    }
}
EOF

        fi

        COMPOSER_REQUIRED=("composer/composer")

        file_to_array "$CONFIG_DIR/composer-packages" '^[[:space:]]*$' '^#'

        if [ "${#FILE_TO_ARRAY[@]}" -gt "0" ]; then

            COMPOSER_REQUIRED+=("${FILE_TO_ARRAY[@]}")

        fi

        # if needed: it's slow, but "./composer.phar show -aN" returns a list of all available composer packages
        install_or_queue "composer" "${COMPOSER_REQUIRED[*]}" Y package packages "./composer.phar show -ND" "" "./composer.phar require"

        popd >/dev/null || die

    fi

    if command_exists sxhkd && command_exists systemctl; then

        mkdir -p "$HOME/.config/sxhkd"
        mkdir -p "$HOME/.local/bin"
        move_file_delete_link "$HOME/.config/sxhkd/sxhkdrc"
        move_file_delete_link "$HOME/.local/bin/sxhkd-do-map.py"
        ln -s "$ROOT_DIR/linux/sxhkd/sxhkdrc" "$HOME/.config/sxhkd/sxhkdrc"
        ln -s "$ROOT_DIR/linux/sxhkd/sxhkd-do-map.py" "$HOME/.local/bin/sxhkd-do-map.py"

        if systemctl --user list-units --full --all 2>/dev/null | grep -Eq '\bsxhkd\.service\b'; then

            systemctl --user disable --now "sxhkd.service" 2>/dev/null || true

        fi

        systemctl --user enable --now --no-block "$ROOT_DIR/linux/sxhkd/sxhkd.service"

    fi

}

# Usage: php_do_apply_setting "/path/to/php.ini" "error_reporting" "E_ALL"
function php_do_apply_setting() {

    local INI_FILE SETTINGNAME SETTINGVALUE SEARCH REPLACE PREFIX=()

    INI_FILE="$1"
    SETTINGNAME="$2"
    SETTINGVALUE="$3"

    [ -w "$INI_FILE" ] || PREFIX+=(sudo)

    set +u

    [ -f "${INI_FILE}.original" ] || "${PREFIX[@]}" cp -p "$INI_FILE" "${INI_FILE}.original" || die

    SEARCH="$(sed_escape_search "$SETTINGNAME")"
    REPLACE="$(sed_escape_replace "$SETTINGNAME = $SETTINGVALUE")"

    if grep -Eq '^\s*'"${SEARCH}"'\s*=' "$INI_FILE"; then

        # we have a defined setting to replace
        "${PREFIX[@]}" sed -E "${SED_IN_PLACE_ARGS[@]}" 's/^\s*'"${SEARCH}"'\s*=.*$/'"${REPLACE}"'/' "$INI_FILE" || die

    elif grep -Eq '^\s*;\s*'"${SEARCH}"'\s*=' "$INI_FILE"; then

        # we have a commented-out setting to replace
        "${PREFIX[@]}" sed -E "${SED_IN_PLACE_ARGS[@]}" 's/^\s*;\s*'"${SEARCH}"'\s*=.*$/'"${REPLACE}"'/' "$INI_FILE" || die

    else

        echo -e "\n$SETTINGNAME = $SETTINGVALUE" | "${PREFIX[@]}" tee -a "$INI_FILE" >/dev/null || die

    fi

    set -u

}

# Usage: php_do_enable_extension "/path/to/php.ini" "extension" "/path/to/extension.so"
function php_do_enable_extension() {

    local INI_FILE SETTINGNAME SETTINGVALUE SEARCHNAME SEARCHVALUE REPLACE PREFIX=()

    INI_FILE="$1"
    SETTINGNAME="$2"
    SETTINGVALUE="$3"

    [ -w "$INI_FILE" ] || PREFIX+=(sudo)

    set +u

    [ -f "${INI_FILE}.original" ] || "${PREFIX[@]}" cp -p "$INI_FILE" "${INI_FILE}.original" || die

    SEARCHNAME="$(sed_escape_search "$SETTINGNAME")"
    SEARCHVALUE="$(sed_escape_search "$SETTINGVALUE")"
    REPLACE="$(sed_escape_replace "$SETTINGNAME = $SETTINGVALUE")"

    # similar to php_do_apply_setting, but match on value too
    if grep -Eq '^\s*'"${SEARCHNAME}"'\s*=\s*'"${SEARCHVALUE}"'\s*$' "$INI_FILE"; then

        # we have a defined setting to replace
        "${PREFIX[@]}" sed -E "${SED_IN_PLACE_ARGS[@]}" 's/^\s*'"${SEARCHNAME}"'\s*=\s*'"${SEARCHVALUE}"'\s*$/'"${REPLACE}"'/' "$INI_FILE" || die

    elif grep -Eq '^\s*;\s*'"${SEARCHNAME}"'\s*=\s*'"${SEARCHVALUE}"'\s*$' "$INI_FILE"; then

        # we have a commented-out setting to replace
        "${PREFIX[@]}" sed -E "${SED_IN_PLACE_ARGS[@]}" 's/^\s*;\s*'"${SEARCHNAME}"'\s*=\s*'"${SEARCHVALUE}"'\s*$/'"${REPLACE}"'/' "$INI_FILE" || die

    else

        echo -e "\n$SETTINGNAME = $SETTINGVALUE" | "${PREFIX[@]}" tee -a "$INI_FILE" >/dev/null || die

    fi

    set -u

}

# Usage: php_apply_setting "/etc/php" "error_reporting" "E_ALL"
function php_apply_setting() {

    local INI_ROOT INI_FILE

    INI_ROOT="$1"

    [ -d "$INI_ROOT" ] || die "Error: $INI_ROOT doesn't exist or isn't a directory"

    shift

    while IFS= read -rd $'\0' INI_FILE; do

        php_do_apply_setting "$INI_FILE" "$@"

    done < <(find "$INI_ROOT" -type f -name php.ini -print0 | sort -z)

}

# Usage: php_enable_extension "/etc/php" "extension" "/path/to/extension.so"
function php_enable_extension() {

    local INI_ROOT INI_FILE

    INI_ROOT="$1"

    [ -d "$INI_ROOT" ] || die "Error: $INI_ROOT doesn't exist or isn't a directory"

    shift

    while IFS= read -rd $'\0' INI_FILE; do

        php_do_enable_extension "$INI_FILE" "$@"

    done < <(find "$INI_ROOT" -type f -name php.ini -print0 | sort -z)

}

# Usage: php_apply_developer_settings "/etc/php"
function php_apply_developer_settings() {

    # display all the errors
    php_apply_setting "$1" error_reporting E_ALL
    php_apply_setting "$1" display_errors On
    php_apply_setting "$1" display_startup_errors On

    # enforce healthy limits
    php_apply_setting "$1" memory_limit 256M

    # enable debugging
    php_apply_setting "$1" xdebug.remote_enable 1
    php_apply_setting "$1" xdebug.remote_autostart 1

    if [ "$IS_MACOS" -eq "1" ]; then

        # support MariaDB via Homebrew
        php_apply_setting "$1" pdo_mysql.default_socket /tmp/mysql.sock
        php_apply_setting "$1" mysql.default_socket /tmp/mysql.sock
        php_apply_setting "$1" mysqli.default_socket /tmp/mysql.sock

    fi

}
