#!/bin/bash
# shellcheck disable=SC1090,SC2015,SC2034,SC2119,SC2120,SC2162

set -euo pipefail

function is_dryrun() {

    [ "$ORIGINAL_DRYRUN_ARGUMENT" = "--dryrun" ] || { [ "${DRYRUN_BY_DEFAULT:-N}" != "N" ] && [ "$ORIGINAL_DRYRUN_ARGUMENT" != "--run" ]; }

}

function dryrun_message() {

    local EXTRA=

    if is_dryrun; then

        [ "${DRYRUN_BY_DEFAULT:-N}" = "N" ] || EXTRA=" (use \"--run\" as the first argument to override)"

        lk_console_message "$(basename "$0") is in dry run mode${EXTRA}" "$LK_BOLD$LK_RED" >&2

    fi

}

# Usage: maybe_dryrun command [argument1...]
function maybe_dryrun() {

    if is_dryrun; then

        lk_console_item "Command skipped (dry run):" "$*" "$YELLOW" >&2

    else

        "$@"

    fi

}

# Usage: install_or_queue "Description of this group" "item1 item2 ..." <allow user override? (y/n)> <singular noun> <plural noun> <name of "installed items" array> <name of "available items" array> <name of "to install" array to fill> [name of "already installed" array to fill]
function install_or_queue() {

    local REQUESTED=($2) UI="$3" SINGLE="$4" PLURAL="$5" ITEMS_INSTALLED ITEMS_AVAILABLE INSTALL_TARGET="$8" ALREADY_INSTALLED_TARGET="${9:-}"

    lk_console_message "Checking ${BOLD}${1}${RESET} $PLURAL"

    local i=6 j k
    for j in ITEMS_INSTALLED ITEMS_AVAILABLE; do

        # k="$6"
        eval 'k="$'"$i"'"'

        if [ -z "$k" ]; then

            eval "$j"'=()'

        elif lk_is_declared "$k"; then

            # ITEMS_INSTALLED=($(printf '%s\n' "${NAME_OF_ARRAY[@]}" | sort | uniq))
            eval "$j"'=($(printf '"'"'%s\n'"'"' "${'"$k"'[@]}" | sort | uniq))'

        else

            # ITEMS_INSTALLED=($(COMMAND | sort | uniq)) || true
            eval "$j"'=($('"$k"' | sort | uniq)) || true'

        fi

        ((i += 1))

    done

    local IOQ_INSTALL IOQ_UNAVAILABLE IOQ_ALREADY_INSTALLED

    IOQ_INSTALL=($(comm -23 <(printf '%s\n' "${REQUESTED[@]}" | sort | uniq) <([ "${#ITEMS_INSTALLED[@]}" -gt "0" ] && printf '%s\n' "${ITEMS_INSTALLED[@]}" || true)))
    IOQ_ALREADY_INSTALLED=($(comm -12 <(printf '%s\n' "${REQUESTED[@]}" | sort | uniq) <([ "${#ITEMS_INSTALLED[@]}" -gt "0" ] && printf '%s\n' "${ITEMS_INSTALLED[@]}" || true)))

    if [ "${#IOQ_ALREADY_INSTALLED[@]}" -gt "0" ] && [ -n "$ALREADY_INSTALLED_TARGET" ]; then

        eval "$ALREADY_INSTALLED_TARGET"'+=("${IOQ_ALREADY_INSTALLED[@]}")'

    fi

    if [ "${#IOQ_INSTALL[@]}" -gt "0" ]; then

        if [ "${#ITEMS_AVAILABLE[@]}" -gt "0" ]; then

            IOQ_UNAVAILABLE=($(comm -23 <(printf '%s\n' "${IOQ_INSTALL[@]}" | sort | uniq) <(printf '%s\n' "${ITEMS_AVAILABLE[@]}")))

            if [ "${#IOQ_UNAVAILABLE[@]}" -gt "0" ]; then

                lk_echo_array "${IOQ_UNAVAILABLE[@]}" | lk_console_list "${#IOQ_UNAVAILABLE[@]} $(lk_maybe_plural "${#IOQ_UNAVAILABLE[@]}" "$SINGLE" "$PLURAL") unavailable for installation:" "$LK_BOLD$LK_RED"

                IOQ_INSTALL=($(comm -12 <(printf '%s\n' "${IOQ_INSTALL[@]}" | sort | uniq) <(printf '%s\n' "${ITEMS_AVAILABLE[@]}")))

                [ "${#IOQ_INSTALL[@]}" -gt "0" ] || return 0

            fi

        fi

        if [ "$UI" = "Y" ]; then

            lk_echo_array "${IOQ_INSTALL[@]}" | lk_console_list "Missing ${#IOQ_INSTALL[@]} $1 $(lk_maybe_plural "${#IOQ_INSTALL[@]}" "$SINGLE" "$PLURAL"):" "$BOLD$MAGENTA"

            lk_confirm "Add the $1 $(lk_maybe_plural "${#IOQ_INSTALL[@]}" "$SINGLE" "$PLURAL") listed above?" Y || return 0

        else

            lk_echo_array "${IOQ_INSTALL[@]}" | lk_console_list "Adding ${#IOQ_INSTALL[@]} $1 $(lk_maybe_plural "${#IOQ_INSTALL[@]}" "$SINGLE" "$PLURAL"):" "$LK_GREEN"

        fi

        if lk_is_declared "$INSTALL_TARGET"; then

            eval "$INSTALL_TARGET"'+=("${IOQ_INSTALL[@]}")'

        else

            # shellcheck disable=SC2086
            eval $INSTALL_TARGET "${IOQ_INSTALL[@]}"

        fi

    fi

}

# Usage: test_host_port my.host.address port-number
function test_host_port() {

    # 1-second timeout -- intended for LAN service availability checks
    gnu_nc -zw 1 "$1" "$2" >/dev/null 2>&1

}

# outputs the installed memory size in MiB
function get_memory_size() {

    local MEMSIZE

    if lk_is_linux; then

        lk_assert_command_exists dmidecode

        sudo dmidecode -t memory | sed -E 's/^\s+(.*)$/\1/' | gnu_grep -Po '(?<=^Size: )[0-9]+(?= MB$)' | awk '{ram+=$1} END {print ram}' || lk_die

    elif lk_is_macos; then

        MEMSIZE="$(sysctl -n hw.memsize)" || lk_die
        echo "$((MEMSIZE / 1024 ** 2))"

    else

        lk_die "Unable to determine memory size on this platform"

    fi
}

function lk_set_root() {
    local SCRIPT_PATH ROOT_DIR
    SCRIPT_PATH="$(realpath "${BASH_SOURCE[0]}" 2>/dev/null)" || SCRIPT_PATH="$(python -c 'import os,sys;print os.path.realpath(sys.argv[1])' "${BASH_SOURCE[0]}")"
    ROOT_DIR="$(dirname "$SCRIPT_PATH")/.."
    LK_ROOT="$(realpath "$ROOT_DIR" 2>/dev/null)" || LK_ROOT="$(python -c 'import os,sys;print os.path.realpath(sys.argv[1])' "$ROOT_DIR")"
}

lk_set_root

. "$LK_ROOT/bash/common-functions"
lk_is_server || . "$LK_ROOT/bash/common-desktop"

lk_trap_err

CONFIG_DIR="$LK_ROOT/etc"
CACHE_DIR="$LK_ROOT/var/cache"
LOG_DIR="$LK_ROOT/var/log"
TEMP_DIR="$LK_ROOT/tmp"

FONTPATH=

ORIGINAL_DRYRUN_ARGUMENT=

if [[ "${1:-}" =~ --(dry)?run ]]; then

    ORIGINAL_DRYRUN_ARGUMENT="$1"
    shift

fi

LK_ARGV=("$@")

mkdir -p "$CACHE_DIR" "$LOG_DIR" "$TEMP_DIR"

eval "$(lk_get_colours '')"

if lk_is_macos; then
    PLATFORM=mac
    FONTPATH="${HOME:+$HOME/Library/Fonts:}/Library/Fonts"
    . "$LK_ROOT/bash/common-macos"
elif lk_is_linux; then
    if lk_is_wsl; then
        PLATFORM=wsl
        FONTPATH="/mnt/c/Windows/Fonts:${HOME:+$HOME/.local/share/fonts:}/usr/share/fonts"
    else
        PLATFORM=linux
        FONTPATH="${HOME:+$HOME/.local/share/fonts:}/usr/share/fonts"
    fi
    [ -f /etc/lsb-release ] && . /etc/lsb-release
    . "$LK_ROOT/bash/common-linux"
else
    lk_die "unknown platform"
fi

[ ! -e "$CONFIG_DIR/settings" ] || . "$CONFIG_DIR/settings"
