#!/bin/bash
# shellcheck disable=SC2034,SC2206,SC2207

set -euo pipefail

function error_trap() {

    echo "Error: $(basename "$0") failed with exit code $1 in $2 at line $3" >&2
    exit "$1"

}

trap 'error_trap "$?" "${BASH_SOURCE[0]}" "$LINENO"' ERR

set -E

function exit_trap() {

    local i

    for i in "${!DELETE_ON_EXIT[@]}"; do

        rm -f "${DELETE_ON_EXIT[$i]}" || true

    done

    for i in "${!KILL_ON_EXIT[@]}"; do

        kill "${KILL_ON_EXIT[$i]}" || true

    done

}

trap exit_trap EXIT

shopt -s expand_aliases
alias pop_return1='{ popd >/dev/null; return 1; }'

ORIGINAL_BASH_SUBSHELL="$BASH_SUBSHELL"
ORIGINAL_ARGUMENTS=("$@")

function gnu_command() {

    local COMMAND

    COMMAND="$1"
    shift

    if [ "$IS_MACOS" -eq "1" ]; then

        command_exists "g${COMMAND}" && COMMAND="g${COMMAND}" || echoc "Warning: GNU $COMMAND not available; $(basename "0") may not work as expected" >&2

    fi

    "$COMMAND" "$@"

}

function gnu_grep() {

    gnu_command grep "$@"

}

function gnu_sed() {

    gnu_command sed "$@"

}

function is_virtual() {

    assert_is_linux

    grep -Eq '^flags\s*:.*\shypervisor(\s|$)' /proc/cpuinfo

}

function assert_is_macos() {

    is_macos || die "Error: $(basename "$0") is not supported on this platform (macOS required)"

}

function is_macos() {

    [ "$IS_MACOS" -eq "1" ]

}

function assert_is_windows() {

    is_windows || die "Error: $(basename "$0") is not supported on this platform (Windows required)"

}

function is_windows() {

    [ "$IS_WSL" -eq "1" ]

}

function assert_is_linux() {

    is_linux || die "Error: $(basename "$0") is not supported on this platform (Linux required)"

}

function is_linux() {

    [ "$IS_LINUX" -eq "1" ]

}

function assert_is_ubuntu() {

    is_ubuntu || die "Error: $(basename "$0") is not supported on this platform (Ubuntu required)"

}

function is_ubuntu() {

    [ "$IS_UBUNTU" -eq "1" ]

}

function assert_has_gui() {

    has_gui || die "Error: $(basename "$0") requires a desktop environment"

}

function has_gui() {

    [ "$HAS_GUI" -eq "1" ]

}

function assert_is_ubuntu_lts() {

    is_ubuntu_lts || die "Error: $(basename "$0") is only supported on LTS releases of Ubuntu"

}

function is_ubuntu_lts() {

    assert_is_ubuntu
    assert_command_exists ubuntu-distro-info

    ubuntu-distro-info --supported-esm | grep "^${DISTRIB_CODENAME}\$" >/dev/null 2>&1

}

function assert_root() {

    is_root || die "Error: $(basename "$0") must be run as the superuser"

}

function assert_not_root() {

    ! is_root || die "Error: $(basename "$0") can't be run as the superuser"

}

function assert_command_exists() {

    command_exists "$1" || die "Error: $(basename "$0") requires $1"

}

function assert_function_exists() {

    function_exists "$1" || die "Error: $(basename "$0") requires Bash function $1"

}

function assert_variable_exists() {

    variable_exists "$1" || die "Error: $(basename "$0") requires variable $1"

}

function is_root() {

    [ "$EUID" -eq "0" ]

}

# the relevant function mustn't depend on other functions
function sudo_function() {

    local FUNCTION

    FUNCTION="$1"
    shift

    sudo bash -c "$(declare -f "$FUNCTION"); $FUNCTION \"\$@\"" "$0" "$@"

}

function command_exists() {

    command -v "$1" >/dev/null 2>&1

}

function function_exists() {

    declare -F "$1" >/dev/null 2>&1

}

function variable_exists() {

    declare -p "$1" >/dev/null 2>&1

}

function user_exists() {

    id "$1" >/dev/null 2>&1

}

function is_bool() {

    [[ "$1" =~ ^(true|false)$ ]]

}

function is_int() {

    [[ "$1" =~ ^[0-9]+$ ]]

}

function is_url() {

    grep -Pq '\b(([\w-]+://?|www[.])[^\s()<>]+(?:\([\w\d]+\)|([^[:punct:]\s]|/)))' <<<"$1"

}

# Usage: echoc "My coloured message" "$BOLD" "$BLUE"
function echoc() {

    echocn "$@"
    echo

}

# as above, but no newline afterwards
function echocn() {

    local MESSAGE COLOURS=

    MESSAGE="$1"
    shift

    if [ "$#" -gt "0" ] && [ -n "$RESET" ]; then

        local IFS=
        COLOURS="$*"
        unset IFS

        MESSAGE="$(search_replace "$RESET" "${RESET}${COLOURS}" "$MESSAGE")"

    fi

    echo -ne "${COLOURS}${MESSAGE}${RESET}"

}

function die() {

    [ "$#" -eq "0" ] || echoc "$@" >&2

    exit 1

}

# Usage: console_message "Main message" "Secondary message with colour too" "$BOLD" "$BLUE"
function console_message() {

    local MESSAGE1 MESSAGE2

    MESSAGE1="$1"
    MESSAGE2="$2"
    shift 2

    echocn "==> " "$@"
    echocn "$MESSAGE1"
    [ -z "$MESSAGE2" ] || echocn " $MESSAGE2" "$@"
    echo

}

# Usage: get_confirmation "Do this?" [default response (y/n)] [force valid response? (y/N)] && { do_it; }
function get_confirmation() {

    local PROMPT=() DEFAULT="${2:-}" FORCE="${3:-N}" YN

    [ -n "$1" ] && PROMPT+=("$1") || true

    case "$DEFAULT" in

    Y)
        PROMPT+=("[Y/n]")
        ;;

    N)
        PROMPT+=("[y/N]")
        ;;

    *)
        PROMPT+=("[y/n]")
        DEFAULT=
        ;;

    esac

    while :; do

        read -rp "${PROMPT[*]} " YN

        [ -z "$YN" ] && [ -n "$DEFAULT" ] && YN="$DEFAULT" || true

        YN="$(upper "$YN")"

        if [ "$FORCE" != "Y" ] || [[ "$YN" =~ ^(Y|YES|N|NO)$ ]]; then

            break

        fi

    done

    [[ "$YN" =~ ^(Y|YES)$ ]]

}

# Usage: file_to_array "/path/to/file" [exclude-pattern...]
function file_to_array() {

    local FILENAME LINE COMMAND=(cat)

    FILENAME="${1:-}"
    [ -n "$FILENAME" ] || die "Filename required"
    shift

    FILE_TO_ARRAY=()
    FILE_TO_ARRAY_FILENAME=

    if [ ! -e "$FILENAME" ]; then

        FILENAME="${FILENAME}-default"

    fi

    if [ -e "$FILENAME" ]; then

        FILE_TO_ARRAY_FILENAME="$FILENAME"

        if [ "$#" -gt "0" ]; then

            COMMAND=(grep -Ev "($(array_join_by ")|(" "$@"))")

        fi

        while IFS= read -r LINE || [ -n "$LINE" ]; do

            FILE_TO_ARRAY+=("$LINE")

        done < <("${COMMAND[@]}" "$FILENAME")

    fi

}

# Usage: single_or_plural <number> "singular noun" "plural noun"
function single_or_plural() {

    if [ "$1" -eq "1" ]; then

        echo "$2"

    else

        echo "$3"

    fi

}

function upper_first() {

    echo "$(echo "$1" | cut -c1 | tr "[:lower:]" "[:upper:]")$(echo "$1" | cut -c2-)"

}

function lower() {

    echo "$1" | tr "[:upper:]" "[:lower:]"

}

function upper() {

    echo "$1" | tr "[:lower:]" "[:upper:]"

}

# Searches the array (must be global, passed by name) for the given value and outputs the first corresponding key if successful.
# Plays nicely with globs and sparse arrays. Outputs nothing and exits non-zero if the value isn't found.
#
# Usage: array_search <needle> <haystack-name>
function array_search() {

    local KEYS VALUE i

    eval KEYS='"${!'"$2"'[@]}"'

    for i in $KEYS; do

        eval VALUE='"${'"$2"'[$i]}"'

        # $VALUE is left unquoted for globbing purposes
        # shellcheck disable=SC2053
        if [[ "$1" == $VALUE ]] || [[ "$VALUE" == $1 ]]; then

            echo "$i"
            return

        fi

    done

    return 1

}

# Usage: array_join_by ":" "${MY_ARRAY[@]}"
function array_join_by() {

    local SEP ARR

    SEP="$1"
    shift

    if [ "$#" -gt "0" ]; then

        ARR=("${@/#/$SEP}")
        ARR[0]="$1"
        printf "%s" "${ARR[@]}"

    fi

}

# Usage: array_join_oxford "${MY_ARRAY[@]}"
function array_join_oxford() {

    local THREE_OR_MORE=0

    echo -n "${1:-}"
    shift

    while [ "$#" -gt "1" ]; do

        THREE_OR_MORE=1
        echo -n ", $1"
        shift

    done

    [ "$THREE_OR_MORE" -eq "0" ] || echo -n ','
    [ "$#" -eq "0" ] || echo -n " and $1"

}

# Usage: sort_words "these words need sorting"
# (output would be "need sorting these words")
function sort_words() {

    local WORDS

    # shellcheck disable=SC2086
    WORDS=($(printf '%s\n' $1 | sort | uniq))

    echo "${WORDS[*]}"

}

function has_argument() {

    array_search "$1" ORIGINAL_ARGUMENTS >/dev/null

}

function is_autostart() {

    has_argument "--autostart"

}

function offer_sudo_password_bypass() {

    # don't proceed if there's no point
    groups | grep -Eq '\b(admin|sudo)\b' || return 0

    local USERNAME="${SUDO_USER:-$USER}" FILENAME CHECK_FILENAME

    FILENAME="/etc/sudoers.d/nopasswd-$USERNAME"
    CHECK_FILENAME="$CACHE_DIR/.nopasswd-$USERNAME"

    if [ -e "$CHECK_FILENAME" ]; then

        return

    fi

    console_message "Please provide your computer password if requested" "" "$BLUE"

    # check that we can, in fact, sudo as root
    if ! sudo true; then

        return 0

    fi

    if ! sudo test -e "$FILENAME"; then

        if get_confirmation "Allow user ${BOLD}${USERNAME}${RESET} to skip future password prompts?" Y Y; then

            sudo tee "$FILENAME" >/dev/null <<<"${USERNAME} ALL=(ALL) NOPASSWD:ALL" && sudo chmod 0440 "$FILENAME" || die

        else

            return 0

        fi

    fi

    # attempt to save time next time
    { touch "$CHECK_FILENAME" || sudo touch "$CHECK_FILENAME"; } >/dev/null 2>&1 || true

}

# Usage: sed_escape_search "text to escape" [extended regular expressions? (Y/n)]
function sed_escape_search() {

    if [ "${2:-Y}" = "Y" ]; then

        # shellcheck disable=SC2016
        echo "${1:-}" | sed 's/[]$()*+./?\^{|}[]/\\&/g'

    else

        echo "${1:-}" | sed 's/[]$*./\^[]/\\&/g'

    fi

}

function sed_escape_replace() {

    local ESCAPED

    ESCAPED="$(echo "${1:-}" | sed 's/[\/&]/\\&/g')"
    echo "${ESCAPED//$'\n'/\\n}"

}

# Usage: search_replace "find" "replace with" "string"
function search_replace() {

    local FIND REPLACE

    FIND="$(sed_escape_search "$1")"
    REPLACE="$(sed_escape_replace "$2")"

    sed -E "s/${FIND}/${REPLACE}/g" <<<"$3"

}

function date_get_log() {

    date -R

}

function date_get_ymdhms() {

    date +'%Y%m%d%H%M%S'

}

function date_get_timestamp() {

    date +'%s'

}

function url_decode() {

    echo -e "${*//%/\\x}"

}

# Results are returned in document order without de-duplication.
#
# Usage: get_urls_from_url "http://url.to/page-with-urls" [regex to limit results...]
function get_urls_from_url() {

    local TEMP_FILE URLS PATTERN

    TEMP_FILE="$(create_temp_file N)"

    wget -qkO "$TEMP_FILE" "$1" || {
        rm -f "$TEMP_FILE"
        die
    }

    shift

    # from: https://daringfireball.net/2009/11/liberal_regex_for_matching_urls
    URLS="$(grep -Po '\b(([\w-]+://?|www[.])[^\s()<>]+(?:\([\w\d]+\)|([^[:punct:]\s]|/)))' "$TEMP_FILE")" || true

    rm -f "$TEMP_FILE"

    for PATTERN in "$@"; do

        URLS="$(echo "$URLS" | grep -E "$PATTERN")" || true

    done

    echo "$URLS"

}

# files are downloaded to the current directory, and local filenames are output
function download_urls() {

    local i DOWNLOAD_FAILED=0 URL PRETTY_URL HEADERS HEADER HEADER_PARTS IFS FILENAME

    for URL in "$@"; do

        FILENAME=
        PRETTY_URL="${NO_WRAP}${URL}${WRAP}"
        HEADERS="$(wget -SNnv "$URL" 2>&1 >/dev/null)" || DOWNLOAD_FAILED=1

        if [ "$DOWNLOAD_FAILED" -eq "1" ]; then

            console_message "Unable to download ($(echo "$HEADERS" | head -n1)):" "$PRETTY_URL" "$BOLD" "$RED" >&2

            if [ -n "${DOWNLOAD_URLS_SKIP_REGEX:-}" ] && [[ "$(echo "$HEADERS" | head -n1)" =~ $DOWNLOAD_URLS_SKIP_REGEX ]]; then

                DOWNLOAD_FAILED=0
                continue

            else

                die

            fi

        fi

        if HEADER="$(
            . "$SUBSHELL_SCRIPT_PATH" || exit
            echo "$HEADERS" | grep -Ei '^[[:space:]]*Content-Disposition:' | tail -n1 | sed -E 's/(^[[:space:]]*Content-Disposition:)//ig'
        )"; then

            IFS=" ;"
            HEADER_PARTS=($HEADER)
            unset IFS

            for i in "${!HEADER_PARTS[@]}"; do

                HEADER="${HEADER_PARTS[$i]}"

                if FILENAME="$(
                    . "$SUBSHELL_SCRIPT_PATH" || exit
                    echo "$HEADER" | grep -Pio '(?<=^filename=).*' | sed -E 's/^[[:space:]]*("?)(.*)\1[[:space:]]*$/\2/g'
                )"; then

                    break

                else

                    FILENAME=

                fi

            done

        fi

        if [ -z "$FILENAME" ] || [ ! -e "$FILENAME" ]; then

            FILENAME="$(url_decode "$URL")"
            FILENAME="${FILENAME##*\/}"

        fi

        if [ ! -e "$FILENAME" ]; then

            console_message "Unable to determine filename for:" "$PRETTY_URL" "$BOLD" "$RED" >&2
            die

        fi

        echo "$(pwd)/$FILENAME"

        console_message "Finished downloading:" "$PRETTY_URL" "$CYAN" >&2

    done

}

function move_file_delete_link() {

    if [ -L "$1" ]; then

        rm -f "$1"

    elif [ -e "$1" ]; then

        mv -f "$1" "$1.bak"

    fi

}

# Usage: create_temp_file [queue for deletion? (Y/n)]
function create_temp_file() {

    local TEMP_PATH

    TEMP_PATH="$(mktemp "/tmp/$(basename "$0").$(date_get_timestamp).XXXXXXXX")" ||
        die "Error: unable to create temporary file"

    if [ "${1:-Y}" = "Y" ]; then

        DELETE_ON_EXIT+=("$TEMP_PATH")

        if [ "$ORIGINAL_BASH_SUBSHELL" -ne "$BASH_SUBSHELL" ]; then

            echoc "WARNING: queuing files for deletion doesn't work in subshells" "$BOLD" >&2

        fi

    fi

    echo "$TEMP_PATH"

}

# Usage: create_temp_file [queue for deletion? (Y/n)]
function create_temp_fifo() {

    local FIFO_PATH

    FIFO_PATH="$(mktemp -u "/tmp/$(basename "$0").$(date_get_timestamp).XXXXXXXX.fifo")" &&
        mkfifo "$FIFO_PATH" ||
        die "Error: unable to create temporary FIFO"

    if [ "${1:-Y}" = "Y" ]; then

        DELETE_ON_EXIT+=("$FIFO_PATH")

        if [ "$ORIGINAL_BASH_SUBSHELL" -ne "$BASH_SUBSHELL" ]; then

            echoc "WARNING: queuing files for deletion doesn't work in subshells" "$BOLD" >&2

        fi

    fi

    echo "$FIFO_PATH"

}

function flush_fifo() {

    dd if="$1" iflag=nonblock of=/dev/null

}

function get_x_displays() {

    assert_has_gui

    local X

    if [ -d /tmp/.X11-unix ]; then

        for X in /tmp/.X11-unix/X*; do

            echo ":${X##*X}"

        done

    fi

}

function dir_make_and_own() {

    assert_not_root

    [ -d "$1" ] || sudo mkdir -p "$1" || die

    [ -w "$1" ] || sudo chown "$(id -un):$(id -gn)" "$1" || die

}

function windows_running_as_administrator() {

    assert_command_exists whoami.exe

    whoami.exe /groups | grep '\bS-1-5-32-544\b.*\bEnabled group\b' >/dev/null

}

# because Bash 3.2 exits when eval exits non-zero, regardless of context or errexit status
function eval_test() {

    local EXIT_CODE

    EXIT_CODE="$(eval 'if' "$@" '; then echo "0"; else echo "1"; fi')"

    return "$EXIT_CODE"

}

function link_settings() {

    local i TO

    assert_command_exists realpath

    APP_NAME="${APP_NAME:-app}"

    if [ -n "${RUNNING_CHECK:-}" ]; then

        if eval_test "$RUNNING_CHECK"; then

            die "Error: $APP_NAME is currently running"

        fi

    fi

    if [ -n "${DIRECTORY_CHECK:-}" ]; then

        if [ ! -d "$DIRECTORY_CHECK" ]; then

            die "Error: $DIRECTORY_CHECK doesn't exist (have you run $APP_NAME yet?)"

        fi

    fi

    if [ "$IS_WSL" -eq "1" ] && ! windows_running_as_administrator; then

        die "Error: for symbolic links to work, $(basename "$0") must be run as administrator"

    fi

    for i in "${!LINK_FROM[@]}"; do

        [ -e "${LINK_TO[$i]}" ] || {
            console_message "Missing file:" "${LINK_TO[$i]}" "$BOLD" "$RED"
            continue
        }

        TO="$(realpath "${LINK_TO[$i]}")" || die
        move_file_delete_link "${LINK_FROM[$i]}" || die
        mkdir -p "$(dirname "${LINK_FROM[$i]}")"
        ln -sv "$TO" "${LINK_FROM[$i]}"

    done

}

# Usage: install_or_queue "Description of this group" "item1 item2 ..." <allow user override? (y/n)> <singular noun> <plural noun> <name of "installed items" array> <name of "available items" array> <name of "to install" array to fill> [name of "already installed" array to fill]
function install_or_queue() {

    local REQUESTED=($2) UI="$3" SINGLE="$4" PLURAL="$5" ITEMS_INSTALLED ITEMS_AVAILABLE INSTALL_TARGET="$8" ALREADY_INSTALLED_TARGET="${9:-}"

    console_message "Checking ${BOLD}${1}${RESET} $PLURAL" "" "$CYAN"

    local i=6 j k
    for j in ITEMS_INSTALLED ITEMS_AVAILABLE; do

        # k="$6"
        eval 'k="$'"$i"'"'

        if [ -z "$k" ]; then

            eval "$j"'=()'

        elif variable_exists "$k"; then

            # ITEMS_INSTALLED=($(printf '%s\n' "${NAME_OF_ARRAY[@]}" | sort | uniq))
            eval "$j"'=($(printf '"'"'%s\n'"'"' "${'"$k"'[@]}" | sort | uniq))'

        else

            # ITEMS_INSTALLED=($(COMMAND | sort | uniq)) || true
            eval "$j"'=($('"$k"' | sort | uniq)) || true'

        fi

        ((i += 1))

    done

    local IOQ_INSTALL IOQ_UNAVAILABLE IOQ_ALREADY_INSTALLED

    IOQ_INSTALL=($(comm -23 <(printf '%s\n' "${REQUESTED[@]}" | sort | uniq) <([ "${#ITEMS_INSTALLED[@]}" -gt "0" ] && printf '%s\n' "${ITEMS_INSTALLED[@]}" || true)))
    IOQ_ALREADY_INSTALLED=($(comm -12 <(printf '%s\n' "${REQUESTED[@]}" | sort | uniq) <([ "${#ITEMS_INSTALLED[@]}" -gt "0" ] && printf '%s\n' "${ITEMS_INSTALLED[@]}" || true)))

    if [ "${#IOQ_ALREADY_INSTALLED[@]}" -gt "0" ] && [ -n "$ALREADY_INSTALLED_TARGET" ]; then

        eval "$ALREADY_INSTALLED_TARGET"'+=("${IOQ_ALREADY_INSTALLED[@]}")'

    fi

    if [ "${#IOQ_INSTALL[@]}" -gt "0" ]; then

        if [ "${#ITEMS_AVAILABLE[@]}" -gt "0" ]; then

            IOQ_UNAVAILABLE=($(comm -23 <(printf '%s\n' "${IOQ_INSTALL[@]}" | sort | uniq) <(printf '%s\n' "${ITEMS_AVAILABLE[@]}")))

            if [ "${#IOQ_UNAVAILABLE[@]}" -gt "0" ]; then

                console_message "${#IOQ_UNAVAILABLE[@]} $(single_or_plural "${#IOQ_UNAVAILABLE[@]}" "$SINGLE" "$PLURAL") unavailable for installation:" "${IOQ_UNAVAILABLE[*]}" "$BOLD" "$RED"

                IOQ_INSTALL=($(comm -12 <(printf '%s\n' "${IOQ_INSTALL[@]}" | sort | uniq) <(printf '%s\n' "${ITEMS_AVAILABLE[@]}")))

                [ "${#IOQ_INSTALL[@]}" -gt "0" ] || return 0

            fi

        fi

        if [ "$UI" = "Y" ]; then

            console_message "Missing ${#IOQ_INSTALL[@]} $1 $(single_or_plural "${#IOQ_INSTALL[@]}" "$SINGLE" "$PLURAL"):" "${IOQ_INSTALL[*]}" "$BOLD" "$MAGENTA"

            get_confirmation "Add the $1 $(single_or_plural "${#IOQ_INSTALL[@]}" "$SINGLE" "$PLURAL") listed above?" Y Y || return 0

        else

            console_message "Adding ${#IOQ_INSTALL[@]} $1 $(single_or_plural "${#IOQ_INSTALL[@]}" "$SINGLE" "$PLURAL"):" "${IOQ_INSTALL[*]}" "$GREEN"

        fi

        if variable_exists "$INSTALL_TARGET"; then

            eval "$INSTALL_TARGET"'+=("${IOQ_INSTALL[@]}")'

        else

            # shellcheck disable=SC2086
            eval $INSTALL_TARGET "${IOQ_INSTALL[@]}"

        fi

    fi

}

COMMON_SCRIPT_PATH="${BASH_SOURCE[0]}"
if command -v realpath >/dev/null 2>&1; then COMMON_SCRIPT_PATH="$(realpath "$COMMON_SCRIPT_PATH")"; fi
ROOT_DIR="$(cd "$(dirname "$COMMON_SCRIPT_PATH")/.." && pwd -P)"
CONFIG_DIR="$ROOT_DIR/config"
CACHE_DIR="$ROOT_DIR/cache"
LOCAL_DIR="$ROOT_DIR/local"
LOG_DIR="$ROOT_DIR/log"
TEMP_DIR="$ROOT_DIR/tmp"

SUBSHELL_SCRIPT_PATH="$ROOT_DIR/bash/common-subshell"
SED_IN_PLACE_ARGS=(-i)

DELETE_ON_EXIT=()
KILL_ON_EXIT=()

mkdir -p "$CONFIG_DIR" "$CACHE_DIR" "$LOCAL_DIR" "$LOG_DIR" "$TEMP_DIR"

if [ -t 1 ]; then

    # foreground colours
    BLACK="$(tput setaf 0)"
    RED="$(tput setaf 1)"
    GREEN="$(tput setaf 2)"
    YELLOW="$(tput setaf 3)"
    BLUE="$(tput setaf 4)"
    MAGENTA="$(tput setaf 5)"
    CYAN="$(tput setaf 6)"
    WHITE="$(tput setaf 7)"

    # background colours
    BLACK_BG="$(tput setab 0)"
    RED_BG="$(tput setab 1)"
    GREEN_BG="$(tput setab 2)"
    YELLOW_BG="$(tput setab 3)"
    BLUE_BG="$(tput setab 4)"
    MAGENTA_BG="$(tput setab 5)"
    CYAN_BG="$(tput setab 6)"
    WHITE_BG="$(tput setab 7)"

    # other "formatting"
    BOLD="$(tput bold)"
    UNDERLINE="$(tput smul)"
    NO_UNDERLINE="$(tput rmul)"
    STANDOUT="$(tput smso)"
    NO_STANDOUT="$(tput rmso)"
    NO_WRAP="$(tput rmam)"
    WRAP="$(tput smam)"
    RESET="$(tput sgr0)"

else

    BLACK=
    RED=
    GREEN=
    YELLOW=
    BLUE=
    MAGENTA=
    CYAN=
    WHITE=
    BLACK_BG=
    RED_BG=
    GREEN_BG=
    YELLOW_BG=
    BLUE_BG=
    MAGENTA_BG=
    CYAN_BG=
    WHITE_BG=
    BOLD=
    UNDERLINE=
    NO_UNDERLINE=
    STANDOUT=
    NO_STANDOUT=
    NO_WRAP=
    WRAP=
    RESET=

fi

IS_MACOS=0
IS_LINUX=0
IS_UBUNTU=0
IS_ELEMENTARY_OS=0
IS_WSL=0
HAS_GUI=0
PLATFORM=

case "$(uname -s)" in

Darwin)

    IS_MACOS=1
    PLATFORM=mac
    HAS_GUI=1
    SED_IN_PLACE_ARGS+=("")
    ;;

Linux)

    IS_LINUX=1

    if [ -e /proc/version ] && grep -q Microsoft /proc/version; then

        IS_WSL=1
        PLATFORM=wsl

    else

        PLATFORM=linux
        command_exists X && HAS_GUI=1

    fi

    if command_exists lsb_release; then

        if [ -e "$CACHE_DIR/.lsb-release" ]; then

            # shellcheck disable=SC1090
            . "$CACHE_DIR/.lsb-release"

        else

            DISTRIB_ID="$(lsb_release -si)"
            LSB_RELEASE_EXTRA=

            if [[ "$DISTRIB_ID" == elementary* ]]; then

                DISTRIB_ID="$(lsb_release -siu)"
                LSB_RELEASE_EXTRA=u
                IS_ELEMENTARY_OS=1

            fi

            DISTRIB_RELEASE="$(lsb_release -sr$LSB_RELEASE_EXTRA)"
            DISTRIB_CODENAME="$(lsb_release -sc$LSB_RELEASE_EXTRA)"
            DISTRIB_DESCRIPTION="$(lsb_release -sd$LSB_RELEASE_EXTRA)"

            cat <<EOF >"$CACHE_DIR/.lsb-release"
DISTRIB_ID="$DISTRIB_ID"
DISTRIB_RELEASE="$DISTRIB_RELEASE"
DISTRIB_CODENAME="$DISTRIB_CODENAME"
DISTRIB_DESCRIPTION="$DISTRIB_DESCRIPTION"
IS_ELEMENTARY_OS=$IS_ELEMENTARY_OS
EOF

        fi

        if [ "$DISTRIB_ID" = "Ubuntu" ]; then

            IS_UBUNTU=1

        fi

    fi

    ;;

*)

    die "Error: unknown platform"
    ;;

esac

[ -e "$CONFIG_DIR/settings-default" ] && . "$CONFIG_DIR/settings-default" || true
[ -e "$CONFIG_DIR/settings" ] && . "$CONFIG_DIR/settings" || true
