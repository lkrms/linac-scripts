#!/bin/bash
# shellcheck disable=SC2034

[ "${QT_BEARER_POLL_TIMEOUT:-}" = "-1" ] || export QT_BEARER_POLL_TIMEOUT=-1

function synergy_find_executable() {

    command -v "$1" ||
        PATH=".:/usr/bin:/usr/local/bin:/Applications/Synergy.app/Contents/MacOS" command -v "$1" ||
        die "Error: unable to find $1 command"

}

function synergy_get_log_file() {

    LOG_FILE="$LOG_DIR/$1.log"

    if [ ! -e "$LOG_FILE" ] && ! touch "$LOG_FILE" 2>/dev/null || [ ! -w "$LOG_FILE" ]; then

        LOG_FILE="$(mktemp "/tmp/$1.XXXXXXXX")" ||
            die "Error: unable to find a writable log file location"

    fi

}

function synergy_kill() {

    if pgrep -x 'synergy[cs]?' >/dev/null; then

        if [ "$EUID" -eq "0" ]; then

            pkill -x 'synergy[cs]?' || true

        else

            pkill -x -u "$USER" 'synergy[cs]?' || true

            sleep 1

            if pgrep -x 'synergy[cs]?' >/dev/null; then

                sudo -n pkill -x 'synergy[cs]?' || true

            fi

        fi

        sleep 1

        if pgrep -x 'synergy[cs]?' >/dev/null; then

            die "Error: synergy is already running"

        fi

    fi

}

function synergy_prepare_command_line() {

    local d xa pid xc i

    COMMAND_LINE=()

    if [ "$IS_LINUX" -eq "1" ] && [ -z "${DISPLAY:-}" ] && [ "$EUID" -eq "0" ]; then

        d="$(get_x_displays | sort | tail -n1)"

        # use Xorg's command line to determine our XAUTHORITY path (alternatively, we could inspect /proc/XXXX/environ)
        if [ -n "$d" ] && pid=($(pgrep -x Xorg)); then

            # shellcheck disable=SC2009,SC2207
            if xc=($(ps "${pid[@]}" | grep -E '[[:space:]]+'"$d"'[[:space:]]+' | grep -E '[[:space:]]+-auth[[:space:]]+[^[:space:]]+')); then

                for i in "${!xc[@]}"; do

                    if [ "${xc[$i]}" = "-auth" ]; then

                        ((i += 1))
                        xa="${xc[$i]}"

                        COMMAND_LINE+=(env "DISPLAY=$d" "XAUTHORITY=$xa")

                        break

                    fi

                done

            fi

        fi

    fi

}

function synergy_daemon_check() {

    case "$(basename "$0")" in

    *daemon*)
        IS_DAEMON=1
        ;;

    *)
        COMMAND_LINE+=(-f)
        IS_DAEMON=0
        ;;

    esac

}

function synergy_loop() {

    while :; do

        synergy_kill

        echo "$(date_get_log) Starting: ${COMMAND_LINE[*]}" >>"$LOG_FILE"

        RESULT=0
        "${COMMAND_LINE[@]}" >>"$LOG_FILE" 2>&1 || RESULT="$?"

        echo "$(date_get_log) Exited with code: $RESULT" >>"$LOG_FILE"

        # restart on unlock if running in the foreground without root privileges
        if [ "$EUID" -ne "0" ] && [ "$IS_DAEMON" -eq "0" ] && [ "$IS_LINUX" -eq "1" ] && command_exists gdbus; then

            echo "$(date_get_log) Waiting for session unlock" >>"$LOG_FILE"

            while IFS= read -r LINE; do

                if [[ "$LINE" == *org.freedesktop.login1.Session.Unlock* ]]; then

                    break

                fi

            done < <(gdbus monitor --system --dest org.freedesktop.login1 --object-path "/org/freedesktop/login1/session/$XDG_SESSION_ID")

            # gdbus will keep running forever otherwise (not even SIGPIPE kills it)
            if SUBSHELL_PID="$(pgrep -P $$)"; then

                pkill -xP "$SUBSHELL_PID" gdbus || true

            fi

            echo "$(date_get_log) Session unlock detected; restarting" >>"$LOG_FILE"

        else

            exit "$RESULT"

        fi

    done

}
