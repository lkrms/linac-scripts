SCRIPT_ARGS=("$@")

function assert_is_macos() {

    if [ "$IS_MACOS" -ne "1" ]; then

        echo "Error: $(basename "$0") is not supported on this platform"
        exit 1

    fi

}

function assert_is_linux() {

    if [ "$IS_LINUX" -ne "1" ]; then

        echo "Error: $(basename "$0") is not supported on this platform"
        exit 1

    fi

}

function assert_is_ubuntu() {

    if [ "$IS_UBUNTU" -ne "1" ]; then

        echo "Error: $(basename "$0") is not supported on this platform"
        exit 1

    fi

}

function assert_is_ubuntu_lts() {

    assert_is_ubuntu

    command -v ubuntu-distro-info >/dev/null 2>&1 || apt_force_install_packages "distro-info"

    if ! ubuntu-distro-info --supported-esm | grep -q '^'"$DISTRIB_CODENAME"'$'; then

        echo "Error: $(basename "$0") is only supported on LTS releases of Ubuntu"
        exit 1

    fi

}

function assert_not_root() {

    if [ "$EUID" -eq "0" ]; then

        echo "Error: $(basename "$0") can't be run as the superuser"
        exit 1

    fi

}

# Usage: argument_or_default VAR_TO_SET "default value if there's not exactly one command line argument"
function argument_or_default() {

    if [ "${#SCRIPT_ARGS[@]}" -eq "1" ]; then

        eval $1="${SCRIPT_ARGS[0]}"

    else

        eval $1="$2"

    fi

}

# Usage: echoc "My coloured message" $BOLD $BLUE
function echoc() {

    echocn "$@"
    echo

}

# as above, but no newline afterwards
function echocn() {

    local MESSAGE="$1" c

    shift

    for c in "$@"; do

        echo -ne "$c"

    done

    echo -ne "${MESSAGE}${RESET}"

}

# Usage: console_message "Main message to display in bold" "Secondary message with colour too" $BLUE
function console_message() {

    local MESSAGE1="$1" MESSAGE2="$2"

    shift
    shift
    echocn "==> " "$@"
    echocn "$MESSAGE1" $BOLD
    [ -n "$MESSAGE2" ] && echocn " $MESSAGE2" $BOLD "$@"
    echo

}

# Usage: get_confirmation "Do this?" && { do_it; }
function get_confirmation() {

    local YN

    read -p "$BOLD$1$RESET [y/n] " YN

    [[ "$YN" =~ ^[Yy]$ ]]

}

# Usage: single_or_plural <number> "singular noun" "plural noun"
function single_or_plural() {

    if [ "$1" -eq "1" ]; then

        echo "$2"

    else

        echo "$3"

    fi

}

# because we can't rely on BASH 4+
function upper_first() {

    echo "$(echo "$1" | cut -c1 | tr [a-z] [A-Z])$(echo "$1" | cut -c2-)"

}

# Usage: array_search <needle> <haystack-name>
function array_search() {

    local HAYSTACK

    eval 'HAYSTACK=("${'"$2"'[@]}")'

    for i in "${!HAYSTACK[@]}"; do

        if [[ "$1" == ${HAYSTACK[$i]} ]]; then

            echo "$i"
            return 0

        fi

    done

    echo "-1"
    return 1

}

function apt_refresh_packages() {

    [ "$IS_DPKG_INSTALLED" -eq "1" -a "$IS_APT_INSTALLED" -eq "1" ] || {
        echo "Error: $(basename "$0") requires dpkg and apt"
        exit 1
    }

    APT_INSTALLED_PACKAGES="$(dpkg-query -f '${binary:Package}\n' -W)"
    APT_AVAILABLE_PACKAGES="$(apt-cache pkgnames)"

}

function apt_package_installed() {

    [ -n "$APT_INSTALLED_PACKAGES" ] || apt_refresh_packages
    echo "$APT_INSTALLED_PACKAGES" | grep -Eq "^$1"'(:.*)?$'

}

function apt_package_available() {

    [ -n "$APT_AVAILABLE_PACKAGES" ] || apt_refresh_packages
    echo "$APT_AVAILABLE_PACKAGES" | grep -Eq "^$1"'(:.*)?$'

}

function apt_ubuntu_archive_url() {

    # attempt to identify a local archive URL
    [ -z "$UBUNTU_ARCHIVE_URL" ] && UBUNTU_ARCHIVE_URL="$(grep -Eo '\bhttps?://([[:alnum:]]+\.)archive\.ubuntu\.com/ubuntu\b' /etc/apt/sources.list | head -n1)/"
    [ "$UBUNTU_ARCHIVE_URL" = "/" ] && UBUNTU_ARCHIVE_URL="http://archive.ubuntu.com/ubuntu/"

    echo "$UBUNTU_ARCHIVE_URL"

}

function do_apt_enable_ubuntu_repository() {

    if ! cat /etc/apt/sources.list | grep -qE '^deb[[:space:]]+https?://([[:alnum:]]+\.)?archive\.ubuntu\.com/ubuntu/?[[:space:]]+'"$1"'[[:space:]]+.*\b'"$2"'\b'; then

        command -v add-apt-repository >/dev/null 2>&1 || apt_force_install_packages "software-properties-common"

        sudo add-apt-repository -yn "deb $(apt_ubuntu_archive_url) $1 $2" || exit 1

        APT_CACHE_DIRTY=1

    fi

}

function apt_enable_ubuntu_repository() {

    assert_is_ubuntu

    [ "$IS_DPKG_INSTALLED" -eq "1" -a "$IS_APT_INSTALLED" -eq "1" ] || {
        echo "Error: $(basename "$0") requires dpkg and apt"
        exit 1
    }

    do_apt_enable_ubuntu_repository "$DISTRIB_CODENAME" "$1"

    [ -n "$2" ] && for suffix in $2; do

        do_apt_enable_ubuntu_repository "${DISTRIB_CODENAME}-${suffix}" "$1"

    done

}

function apt_enable_partner_repository() {

    assert_is_ubuntu

    [ "$IS_DPKG_INSTALLED" -eq "1" -a "$IS_APT_INSTALLED" -eq "1" ] || {
        echo "Error: $(basename "$0") requires dpkg and apt"
        exit 1
    }

    if ! cat /etc/apt/sources.list | grep -qE '^deb[[:space:]]+https?://([[:alnum:]]+\.)?archive\.canonical\.com/ubuntu/?[[:space:]]+'"$DISTRIB_CODENAME"'[[:space:]]+.*\bpartner\b'; then

        command -v add-apt-repository >/dev/null 2>&1 || apt_force_install_packages "software-properties-common"

        sudo add-apt-repository -yn "deb http://archive.canonical.com/ubuntu $DISTRIB_CODENAME partner" || exit 1

        APT_CACHE_DIRTY=1

    fi

}

# Usage: apt_register_ppa "the/ppa" "package1 package2 ..."
function apt_register_ppa() {

    command -v add-apt-repository >/dev/null 2>&1 || apt_force_install_packages "software-properties-common"

    if ! cat /etc/apt/sources.list /etc/apt/sources.list.d/*.list 2>/dev/null | grep -q "^[^#]*/$1"; then

        for p in $2; do

            # without BASH 4+, we have to kludge our associative arrays
            APT_PPA_REGISTRY+=("$1")
            APT_PPA_PACKAGES+=("$p")

        done

    fi

}

function apt_add_key_from_url() {

    curl -fsSL "$1" | sudo apt-key add -

}

# Usage: apt_register_repository my-repo-identifier "https://gpg.key.url" "content for my-repo-identifier.list" "package1 package2 ..."
function apt_register_repository() {

    [ "$IS_DPKG_INSTALLED" -eq "1" -a "$IS_APT_INSTALLED" -eq "1" ] || {
        echo "Error: $(basename "$0") requires dpkg and apt"
        exit 1
    }

    command -v curl >/dev/null 2>&1 || apt_force_install_packages "curl"

    if [ ! -e "/etc/apt/sources.list.d/$1.list" ]; then

        for p in $4; do

            # without BASH 4+, we have to kludge our associative arrays
            APT_REPO_REGISTRY+=("$1")
            APT_REPO_KEY_URLS+=("$2")
            APT_REPO_ENTRIES+=("$3")
            APT_REPO_PACKAGES+=("$p")

        done

    else

        # because keys change sometimes
        apt_add_key_from_url "$2"

    fi

}

function apt_make_cache_clean() {

    [ "$IS_DPKG_INSTALLED" -eq "1" -a "$IS_APT_INSTALLED" -eq "1" ] || {
        echo "Error: $(basename "$0") requires dpkg and apt"
        exit 1
    }

    [ "$APT_CACHE_DIRTY" -eq "0" ] || sudo apt-get -qq update && APT_CACHE_DIRTY=0 || {
        echo "Error: apt-get update failed"
        exit 1
    }

}

# Usage: apt_install_packages "Description of this group of packages" "package1 package2 ..." [allow user override (Y/N)] [queue only (Y/N)]
function apt_install_packages() {

    local UI="$3" QUEUE_ONLY="$4"
    [ "$UI" = "Y" ] || UI=N
    [ "$QUEUE_ONLY" = "Y" ] || QUEUE_ONLY=N

    apt_make_cache_clean

    local INSTALLED=() INSTALL=() CANT_INSTALL=() PPA_QUEUE=() PPA_INDEX REPO_QUEUE=() REPO_INDEX

    [ "$UI" = "Y" ] && console_message "Checking $1..." "" $BLUE

    for p in $2; do

        PPA_INDEX=$(array_search "$p" APT_PPA_PACKAGES)
        REPO_INDEX=$(array_search "$p" APT_REPO_PACKAGES)

        if [ "$PPA_INDEX" -gt "-1" ]; then

            INSTALL+=("$p")
            PPA_QUEUE+=("${APT_PPA_REGISTRY[$PPA_INDEX]}")

        elif [ "$REPO_INDEX" -gt "-1" ]; then

            INSTALL+=("$p")
            REPO_QUEUE+=("${APT_REPO_REGISTRY[$REPO_INDEX]}")

        elif apt_package_installed "$p"; then

            INSTALLED+=("$p")

        elif apt_package_available "$p"; then

            INSTALL+=("$p")

        else

            CANT_INSTALL+=("$p")

        fi

    done

    [ "$UI" = "Y" -a "${#INSTALLED[@]}" -gt "0" ] && console_message "$(single_or_plural ${#INSTALLED[@]} Package Packages) already installed:" "${INSTALLED[*]}" $GREEN
    [ "${#CANT_INSTALL[@]}" -gt "0" ] && console_message "$(single_or_plural ${#CANT_INSTALL[@]} Package Packages) unavailable for installation:" "${CANT_INSTALL[*]}" $RED

    if [ "${#INSTALL[@]}" -gt "0" ]; then

        console_message "$(upper_first "$1") packages to install:" "${INSTALL[*]}" $BLUE
        [ "${#PPA_QUEUE[@]}" -gt "0" ] && console_message "$(single_or_plural ${#PPA_QUEUE[@]} PPA PPAs) to add:" "${PPA_QUEUE[*]}" $BLUE
        [ "${#REPO_QUEUE[@]}" -gt "0" ] && console_message "$(single_or_plural ${#REPO_QUEUE[@]} Repository Repositories) to add:" "${REPO_QUEUE[*]}" $BLUE

        if [ "$UI" = "Y" ]; then

            :

        fi

        if [ "$QUEUE_ONLY" != "Y" ]; then

            [ "${#PPA_QUEUE[@]}" -gt "0" ] && {
                console_message "Adding ${#PPA_QUEUE[@]} $(single_or_plural ${#PPA_QUEUE[@]} PPA PPAs):" "${PPA_QUEUE[*]}" $GREEN
                apt_add_ppa "${PPA_QUEUE[@]}"
            }

            [ "${#REPO_QUEUE[@]}" -gt "0" ] && {
                console_message "Adding ${#REPO_QUEUE[@]} $(single_or_plural ${#REPO_QUEUE[@]} repository repositories):" "${REPO_QUEUE[*]}" $GREEN
                apt_add_repo "${REPO_QUEUE[@]}"
            }

            console_message "Installing ${#INSTALL[@]} $(single_or_plural ${#INSTALL[@]} package packages):" "${INSTALL[*]}" $GREEN
            apt_make_cache_clean
            sudo apt-get -y install "${INSTALL[@]}" && [ "${#CANT_INSTALL[@]}" -eq "0" ]
            return

        else

            APT_INSTALL_QUEUE+=("${INSTALL[@]}")
            APT_PPA_QUEUE+=("${PPA_QUEUE[@]}")
            APT_REPO_QUEUE+=("${REPO_QUEUE[@]}")
            return 1

        fi

    else

        [ "${#CANT_INSTALL[@]}" -eq "0" ]
        return

    fi

}

function apt_add_ppa() {

    local ppa i

    for ppa in $(printf '%s\n' "$@" | sort | uniq); do

        [ -z "$ppa" ] && continue

        sudo add-apt-repository -yn "ppa:$ppa" || exit 1

        APT_CACHE_DIRTY=1

        for i in "${!APT_PPA_REGISTRY[@]}"; do

            if [ "$ppa" = "${APT_PPA_REGISTRY[$i]}" ]; then

                unset APT_PPA_REGISTRY[$i]
                unset APT_PPA_PACKAGES[$i]

            fi

        done

        for i in "${!APT_PPA_QUEUE[@]}"; do

            if [ "$ppa" = "${APT_PPA_QUEUE[$i]}" ]; then

                unset APT_PPA_QUEUE[$i]

            fi

        done

    done

}

function apt_add_repo() {

    local repo i KEY_URL ENTRY

    for repo in $(printf '%s\n' "$@" | sort | uniq); do

        [ -z "$repo" ] && continue

        i=$(array_search "$repo" APT_REPO_REGISTRY) || {
            echo "Error: unable to find metadata for repository '$repo'"
            exit 1
        }

        KEY_URL="${APT_REPO_KEY_URLS[$i]}"
        ENTRY="${APT_REPO_ENTRIES[$i]}"

        echo "$ENTRY" | sudo tee "/etc/apt/sources.list.d/$repo.list" >/dev/null || exit 1
        apt_add_key_from_url "$KEY_URL" || exit 1

        APT_CACHE_DIRTY=1

        for i in "${!APT_REPO_REGISTRY[@]}"; do

            if [ "$repo" = "${APT_REPO_REGISTRY[$i]}" ]; then

                unset APT_REPO_REGISTRY[$i]
                unset APT_REPO_KEY_URLS[$i]
                unset APT_REPO_ENTRIES[$i]
                unset APT_REPO_PACKAGES[$i]

            fi

        done

        for i in "${!APT_REPO_QUEUE[@]}"; do

            if [ "$repo" = "${APT_REPO_QUEUE[$i]}" ]; then

                unset APT_REPO_QUEUE[$i]

            fi

        done

    done

}

function apt_process_queue() {

    RETURN_VALUE=0

    if [ "${#APT_INSTALL_QUEUE[@]}" -gt "0" ]; then

        [ "${#APT_PPA_QUEUE[@]}" -gt "0" ] && {
            console_message "Adding ${#APT_PPA_QUEUE[@]} $(single_or_plural ${#APT_PPA_QUEUE[@]} PPA PPAs):" "${APT_PPA_QUEUE[*]}" $GREEN
            apt_add_ppa "${APT_PPA_QUEUE[@]}"
        }

        [ "${#APT_REPO_QUEUE[@]}" -gt "0" ] && {
            console_message "Adding ${#APT_REPO_QUEUE[@]} $(single_or_plural ${#APT_REPO_QUEUE[@]} repository repositories):" "${APT_REPO_QUEUE[*]}" $GREEN
            apt_add_repo "${APT_REPO_QUEUE[@]}"
        }

        console_message "Installing ${#APT_INSTALL_QUEUE[@]} $(single_or_plural ${#APT_INSTALL_QUEUE[@]} package packages):" "${APT_INSTALL_QUEUE[*]}" $GREEN
        apt_make_cache_clean
        sudo apt-get -y install "${APT_INSTALL_QUEUE[@]}" && APT_INSTALL_QUEUE=() || RETURN_VALUE=1

    fi

    return $RETURN_VALUE

}

function apt_force_install_packages() {

    apt_install_packages "prerequisites" "$1" || exit 1

}

# foreground colours
BLACK="$(tput setaf 0)"
RED="$(tput setaf 1)"
GREEN="$(tput setaf 2)"
YELLOW="$(tput setaf 3)"
BLUE="$(tput setaf 4)"
MAGENTA="$(tput setaf 5)"
CYAN="$(tput setaf 6)"
WHITE="$(tput setaf 7)"

# background colours
BLACK_BG="$(tput setab 0)"
RED_BG="$(tput setab 1)"
GREEN_BG="$(tput setab 2)"
YELLOW_BG="$(tput setab 3)"
BLUE_BG="$(tput setab 4)"
MAGENTA_BG="$(tput setab 5)"
CYAN_BG="$(tput setab 6)"
WHITE_BG="$(tput setab 7)"

# other "formatting"
BOLD="$(tput bold)"
UNDERLINE="$(tput smul)"
NO_UNDERLINE="$(tput rmul)"
STANDOUT="$(tput smso)"
NO_STANDOUT="$(tput rmso)"
RESET="$(tput sgr0)"

IS_MACOS=0
IS_LINUX=0
IS_UBUNTU=0
IS_ELEMENTARY_OS=0
IS_PURE_LINUX=0
IS_WSL=0
PLATFORM=

case "$(uname -s)" in

Darwin)

    IS_MACOS=1
    PLATFORM=mac

    ;;

Linux)

    IS_LINUX=1

    if [ -e /proc/version ] && grep -q Microsoft /proc/version; then

        IS_WSL=1
        PLATFORM=wsl

    else

        IS_PURE_LINUX=1
        PLATFORM=linux

    fi

    if command -v lsb_release >/dev/null 2>&1; then

        DISTRIB_ID="$(lsb_release -si)"
        LSB_RELEASE_EXTRA=

        if [[ "$DISTRIB_ID" == elementary* ]]; then

            DISTRIB_ID="$(lsb_release -siu)"
            LSB_RELEASE_EXTRA=u
            IS_ELEMENTARY_OS=1

        fi

        if [ "$DISTRIB_ID" = "Ubuntu" ]; then

            IS_UBUNTU=1

        fi

        DISTRIB_RELEASE="$(lsb_release -sr$LSB_RELEASE_EXTRA)"
        DISTRIB_CODENAME="$(lsb_release -sc$LSB_RELEASE_EXTRA)"
        DISTRIB_DESCRIPTION="$(lsb_release -sd$LSB_RELEASE_EXTRA)"

    fi

    IS_APT_INSTALLED=1
    IS_DPKG_INSTALLED=1
    IS_SNAP_INSTALLED=1

    command -v apt-get >/dev/null 2>&1 || IS_APT_INSTALLED=0
    command -v dpkg >/dev/null 2>&1 || IS_DPKG_INSTALLED=0
    command -v snap >/dev/null 2>&1 || IS_SNAP_INSTALLED=0

    if [ "$IS_DPKG_INSTALLED" -eq "1" -a "$IS_APT_INSTALLED" -eq "1" ]; then

        APT_CACHE_DIRTY=1
        APT_PPA_REGISTRY=()
        APT_PPA_PACKAGES=()
        APT_REPO_REGISTRY=()
        APT_REPO_KEY_URLS=()
        APT_REPO_ENTRIES=()
        APT_REPO_PACKAGES=()
        APT_INSTALL_QUEUE=()
        APT_REMOVE_QUEUE=()
        APT_PPA_QUEUE=()
        APT_REPO_QUEUE=()

    fi

    ;;

*)

    echo "Error: unknown platform"
    exit 1

    ;;

esac
