SCRIPT_ARGS=("$@")

function assert_is_macos() {

    if [ "$IS_MACOS" -ne "1" ]; then

        echo "Error: $(basename "$0") is not supported on this platform"
        exit 1

    fi

}

function assert_is_linux() {

    if [ "$IS_LINUX" -ne "1" ]; then

        echo "Error: $(basename "$0") is not supported on this platform"
        exit 1

    fi

}

function assert_is_ubuntu() {

    if [ "$IS_UBUNTU" -ne "1" ]; then

        echo "Error: $(basename "$0") is not supported on this platform"
        exit 1

    fi

}

function assert_is_ubuntu_lts() {

    assert_is_ubuntu

    command -v ubuntu-distro-info >/dev/null 2>&1 || apt_force_install_packages "distro-info"

    if ! ubuntu-distro-info --supported-esm | grep -q "^${DISTRIB_CODENAME}\$"; then

        echo "Error: $(basename "$0") is only supported on LTS releases of Ubuntu"
        exit 1

    fi

}

function assert_not_root() {

    if [ "$EUID" -eq "0" ]; then

        echo "Error: $(basename "$0") can't be run as the superuser"
        exit 1

    fi

}

# Usage: argument_or_default VAR_TO_SET "default value if there's not exactly one command line argument"
function argument_or_default() {

    if [ "${#SCRIPT_ARGS[@]}" -eq "1" ]; then

        eval $1="${SCRIPT_ARGS[0]}"

    else

        eval $1="$2"

    fi

}

# Usage: echoc "My coloured message" $BOLD $BLUE
function echoc() {

    echocn "$@"
    echo

}

# as above, but no newline afterwards
function echocn() {

    local MESSAGE="$1" c

    shift

    for c in "$@"; do

        echo -ne "$c"

    done

    echo -ne "${MESSAGE}${RESET}"

}

# Usage: console_message "Main message to display in bold" "Secondary message with colour too" $BLUE
function console_message() {

    local MESSAGE1="$1" MESSAGE2="$2"

    shift
    shift
    echocn "==> " "$@"
    echocn "$MESSAGE1" $BOLD
    [ -n "$MESSAGE2" ] && echocn " $MESSAGE2" $BOLD "$@"
    echo

}

# Usage: get_confirmation "Do this?" && { do_it; }
function get_confirmation() {

    local YN

    read -p "$BOLD$1$RESET [y/n] " YN

    [[ "$YN" =~ ^[Yy]$ ]]

}

# Usage: single_or_plural <number> "singular noun" "plural noun"
function single_or_plural() {

    if [ "$1" -eq "1" ]; then

        echo "$2"

    else

        echo "$3"

    fi

}

# because we can't rely on BASH 4+
function upper_first() {

    echo "$(echo "$1" | cut -c1 | tr "[a-z]" "[A-Z]")$(echo "$1" | cut -c2-)"

}

# Searches the array (must be global, passed by name) for the given value and outputs the first corresponding key if successful.
# Plays nicely with globs and sparse arrays. Outputs -1 and a non-zero exit code if the value isn't found.
#
# Usage: array_search <needle> <haystack-name>
function array_search() {

    local KEYS VALUE

    eval KEYS='"${!'"$2"'[@]}"'

    for i in $KEYS; do

        eval VALUE='"${'"$2"'[$i]}"'

        # $VALUE is left unquoted for globbing purposes
        if [[ "$1" == $VALUE ]]; then

            echo "$i"
            return 0

        fi

    done

    echo "-1"
    return 1

}

RS_SCRIPT_PATH="${BASH_SOURCE[0]}"
[ -L "$RS_SCRIPT_PATH" ] && RS_SCRIPT_PATH="$(readlink "$RS_SCRIPT_PATH")"
RS_SCRIPT_DIR="$(cd "$(dirname "$RS_SCRIPT_PATH")" && pwd -P)"

# foreground colours
BLACK="$(tput setaf 0)"
RED="$(tput setaf 1)"
GREEN="$(tput setaf 2)"
YELLOW="$(tput setaf 3)"
BLUE="$(tput setaf 4)"
MAGENTA="$(tput setaf 5)"
CYAN="$(tput setaf 6)"
WHITE="$(tput setaf 7)"

# background colours
BLACK_BG="$(tput setab 0)"
RED_BG="$(tput setab 1)"
GREEN_BG="$(tput setab 2)"
YELLOW_BG="$(tput setab 3)"
BLUE_BG="$(tput setab 4)"
MAGENTA_BG="$(tput setab 5)"
CYAN_BG="$(tput setab 6)"
WHITE_BG="$(tput setab 7)"

# other "formatting"
BOLD="$(tput bold)"
UNDERLINE="$(tput smul)"
NO_UNDERLINE="$(tput rmul)"
STANDOUT="$(tput smso)"
NO_STANDOUT="$(tput rmso)"
RESET="$(tput sgr0)"

IS_MACOS=0
IS_LINUX=0
IS_UBUNTU=0
IS_ELEMENTARY_OS=0
IS_PURE_LINUX=0
IS_WSL=0
PLATFORM=

case "$(uname -s)" in

Darwin)

    IS_MACOS=1
    PLATFORM=mac

    ;;

Linux)

    IS_LINUX=1

    if [ -e /proc/version ] && grep -q Microsoft /proc/version; then

        IS_WSL=1
        PLATFORM=wsl

    else

        IS_PURE_LINUX=1
        PLATFORM=linux

    fi

    if command -v lsb_release >/dev/null 2>&1; then

        DISTRIB_ID="$(lsb_release -si)"
        LSB_RELEASE_EXTRA=

        if [[ "$DISTRIB_ID" == elementary* ]]; then

            DISTRIB_ID="$(lsb_release -siu)"
            LSB_RELEASE_EXTRA=u
            IS_ELEMENTARY_OS=1

        fi

        if [ "$DISTRIB_ID" = "Ubuntu" ]; then

            IS_UBUNTU=1

        fi

        DISTRIB_RELEASE="$(lsb_release -sr$LSB_RELEASE_EXTRA)"
        DISTRIB_CODENAME="$(lsb_release -sc$LSB_RELEASE_EXTRA)"
        DISTRIB_DESCRIPTION="$(lsb_release -sd$LSB_RELEASE_EXTRA)"

    fi

    IS_APT_INSTALLED=1
    IS_SNAP_INSTALLED=1

    command -v apt-get >/dev/null 2>&1 && command -v dpkg >/dev/null 2>&1 || IS_APT_INSTALLED=0
    command -v snap >/dev/null 2>&1 || IS_SNAP_INSTALLED=0

    ;;

*)

    echo "Error: unknown platform"
    exit 1

    ;;

esac
