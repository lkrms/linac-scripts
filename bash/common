set -euo pipefail

SCRIPT_ARGS=("$@")

function assert_is_macos() {

    if [ "$IS_MACOS" -ne "1" ]; then

        die "Error: $(basename "$0") is not supported on this platform (macOS required)"

    fi

}

function assert_is_linux() {

    if [ "$IS_LINUX" -ne "1" ]; then

        die "Error: $(basename "$0") is not supported on this platform (Linux required)"

    fi

}

function assert_is_ubuntu() {

    if [ "$IS_UBUNTU" -ne "1" ]; then

        die "Error: $(basename "$0") is not supported on this platform (Ubuntu required)"

    fi

}

function assert_apt_available() {

    assert_is_linux

    if [ "$IS_APT_INSTALLED" -ne "1" ]; then

        die "Error: $(basename "$0") requires apt and dpkg"

    fi

}

function assert_is_ubuntu_lts() {

    assert_is_ubuntu

    command -v ubuntu-distro-info &>/dev/null || apt_request_package "distro-info"

    if ! ubuntu-distro-info --supported-esm | grep "^${DISTRIB_CODENAME}\$" &>/dev/null; then

        die "Error: $(basename "$0") is only supported on LTS releases of Ubuntu"

    fi

}

function assert_root() {

    if [ "$EUID" -ne "0" ]; then

        die "Error: $(basename "$0") must be run as the superuser"

    fi

}

function assert_not_root() {

    if [ "$EUID" -eq "0" ]; then

        die "Error: $(basename "$0") can't be run as the superuser"

    fi

}

# Usage: echoc "My coloured message" $BOLD $BLUE
function echoc() {

    echocn "$@"
    echo

}

# as above, but no newline afterwards
function echocn() {

    local MESSAGE="$1" c

    shift

    for c in "$@"; do

        echo -ne "$c"

    done

    echo -ne "${MESSAGE}${RESET}"

}

function die() {

    [ "$#" -gt "0" ] && echoc "$@" >&2

    exit 1

}

# Usage: console_message "Main message to display in bold" "Secondary message with colour too" $BLUE
function console_message() {

    local MESSAGE1="$1" MESSAGE2="$2"

    shift
    shift
    echocn "==> " "$@"
    echocn "$MESSAGE1" $BOLD
    [ -n "$MESSAGE2" ] && echocn " $MESSAGE2" $BOLD "$@"
    echo

}

# Usage: get_confirmation "Do this?" && { do_it; }
function get_confirmation() {

    local YN

    read -p "$BOLD$1$RESET [y/n] " YN

    [[ "$YN" =~ ^[Yy]$ ]]

}

# Usage: single_or_plural <number> "singular noun" "plural noun"
function single_or_plural() {

    if [ "$1" -eq "1" ]; then

        echo "$2"

    else

        echo "$3"

    fi

}

# because we can't rely on BASH 4+
function upper_first() {

    echo "$(echo "$1" | cut -c1 | tr "[a-z]" "[A-Z]")$(echo "$1" | cut -c2-)"

}

# Searches the array (must be global, passed by name) for the given value and outputs the first corresponding key if successful.
# Plays nicely with globs and sparse arrays. Returns an empty string if the value isn't found.
#
# Usage: array_search <needle> <haystack-name>
function array_search() {

    local KEYS VALUE

    eval KEYS='"${!'"$2"'[@]}"'

    for i in $KEYS; do

        eval VALUE='"${'"$2"'[$i]}"'

        # $VALUE is left unquoted for globbing purposes
        if [[ "$1" == $VALUE ]]; then

            echo "$i"
            return

        fi

    done

    return 1

}

function offer_sudo_password_bypass() {

    local USERNAME="${SUDO_USER:-}" FILENAME
    [ -n "$USERNAME" ] || USERNAME="$USER"

    FILENAME="/etc/sudoers.d/nopasswd-$USERNAME"

    if ! sudo test -e "$FILENAME"; then

        if get_confirmation "Allow user '$USERNAME' to skip future password prompts?"; then

            sudo tee "$FILENAME" >/dev/null <<EOF && sudo chmod 0440 "$FILENAME"
${USERNAME} ALL=(ALL) NOPASSWD:ALL
EOF

        fi

    fi

}

RS_SCRIPT_PATH="${BASH_SOURCE[0]}"
[ -L "$RS_SCRIPT_PATH" ] && RS_SCRIPT_PATH="$(readlink "$RS_SCRIPT_PATH")"
RS_ROOT_DIR="$(cd "$(dirname "$RS_SCRIPT_PATH")/.." && pwd -P)"
RS_CACHE_DIR="$RS_ROOT_DIR/cache"
RS_TEMP_DIR="$RS_ROOT_DIR/tmp"

mkdir -p "$RS_CACHE_DIR" "$RS_TEMP_DIR"

# foreground colours
BLACK="$(tput setaf 0)"
RED="$(tput setaf 1)"
GREEN="$(tput setaf 2)"
YELLOW="$(tput setaf 3)"
BLUE="$(tput setaf 4)"
MAGENTA="$(tput setaf 5)"
CYAN="$(tput setaf 6)"
WHITE="$(tput setaf 7)"

# background colours
BLACK_BG="$(tput setab 0)"
RED_BG="$(tput setab 1)"
GREEN_BG="$(tput setab 2)"
YELLOW_BG="$(tput setab 3)"
BLUE_BG="$(tput setab 4)"
MAGENTA_BG="$(tput setab 5)"
CYAN_BG="$(tput setab 6)"
WHITE_BG="$(tput setab 7)"

# other "formatting"
BOLD="$(tput bold)"
UNDERLINE="$(tput smul)"
NO_UNDERLINE="$(tput rmul)"
STANDOUT="$(tput smso)"
NO_STANDOUT="$(tput rmso)"
RESET="$(tput sgr0)"

IS_MACOS=0
IS_LINUX=0
IS_UBUNTU=0
IS_ELEMENTARY_OS=0
IS_PURE_LINUX=0
IS_WSL=0
PLATFORM=

case "$(uname -s)" in

Darwin)

    IS_MACOS=1
    PLATFORM=mac

    ;;

Linux)

    IS_LINUX=1

    if [ -e /proc/version ] && grep -q Microsoft /proc/version; then

        IS_WSL=1
        PLATFORM=wsl

    else

        IS_PURE_LINUX=1
        PLATFORM=linux

    fi

    if command -v lsb_release &>/dev/null; then

        DISTRIB_ID="$(lsb_release -si)"
        LSB_RELEASE_EXTRA=

        if [[ "$DISTRIB_ID" == elementary* ]]; then

            DISTRIB_ID="$(lsb_release -siu)"
            LSB_RELEASE_EXTRA=u
            IS_ELEMENTARY_OS=1

        fi

        if [ "$DISTRIB_ID" = "Ubuntu" ]; then

            IS_UBUNTU=1

        fi

        DISTRIB_RELEASE="$(lsb_release -sr$LSB_RELEASE_EXTRA)"
        DISTRIB_CODENAME="$(lsb_release -sc$LSB_RELEASE_EXTRA)"
        DISTRIB_DESCRIPTION="$(lsb_release -sd$LSB_RELEASE_EXTRA)"

    fi

    IS_APT_INSTALLED=1
    IS_SNAP_INSTALLED=1

    { command -v apt-get &>/dev/null && command -v dpkg &>/dev/null; } || IS_APT_INSTALLED=0
    command -v snap &>/dev/null || IS_SNAP_INSTALLED=0

    ;;

*)

    die "Error: unknown platform"

    ;;

esac
