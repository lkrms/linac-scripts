#!/bin/bash
# shellcheck disable=SC1087,SC2015,SC2016,SC2024,SC2034,SC2068,SC2119,SC2120,SC2207

# common-functions
#   Provide various portable, self-contained Bash functions.

# lk_warn message
function lk_warn() {
    local EXIT_STATUS="$?"
    echo "$(basename "$0"): $1" >&2
    return "$EXIT_STATUS"
}

# lk_die [message]
#   Output optional MESSAGE to stderr and exit with a non-zero status.
function lk_die() {
    local EXIT_STATUS="$?"
    [ "$EXIT_STATUS" -ne "0" ] || EXIT_STATUS="1"
    [ "$#" -eq "0" ] || echo "$(basename "$0"): $1" >&2
    lk_is_true "${LK_DIE_HAPPY:-0}" || exit "$EXIT_STATUS"
    exit 0
}

function lk_trap_err() {
    function lk_err_trap() {
        lk_die "unhandled error at $1:$2"
    }
    trap 'lk_err_trap "${BASH_SOURCE[0]}" "$LINENO"' ERR
}

function lk_trap_exit() {
    function lk_exit_trap() {
        local i
        for i in ${LK_EXIT_DELETE[@]+"${LK_EXIT_DELETE[@]}"}; do
            rm -Rf -- "$i" || true
        done
        for i in ${LK_EXIT_KILL[@]+"${LK_EXIT_KILL[@]}"}; do
            kill "$i" || true
        done
    }
    LK_EXIT_DELETE=()
    LK_EXIT_KILL=()
    trap 'lk_exit_trap' EXIT
}

function lk_delete_on_exit() {
    if ! lk_variable_set "LK_EXIT_DELETE"; then
        lk_trap_exit
    fi
    LK_EXIT_DELETE+=("$@")
}

function lk_kill_on_exit() {
    if ! lk_variable_set "LK_EXIT_KILL"; then
        lk_trap_exit
    fi
    LK_EXIT_KILL+=("$@")
}

function lk_mktemp_file() {
    TMPDIR="${TMPDIR:-/tmp}" gnu_mktemp -t "$(basename "$0").$(lk_timestamp).XXX"
}

function lk_mktemp_dir() {
    TMPDIR="${TMPDIR:-/tmp}" gnu_mktemp -dt "$(basename "$0").$(lk_timestamp).XXX"
}

function lk_command_exists() {
    while [ "$#" -gt "0" ]; do
        command -v "$1" >/dev/null 2>&1 || return
        shift
    done
}

function lk_which_command() {
    local COMMAND
    for COMMAND in "$@"; do
        if command -v "$COMMAND" >/dev/null 2>&1; then
            echo "$COMMAND"
            return
        fi
    done
    return 1
}

# lk_bash_at_least major minor
function lk_bash_at_least() {
    [ "${BASH_VERSINFO[0]}" -eq "$1" ] &&
        [ "${BASH_VERSINFO[1]}" -ge "$2" ] ||
        [ "${BASH_VERSINFO[0]}" -gt "$1" ]
}

if lk_bash_at_least 4 2; then
    function lk_date() {
        # take advantage of printf support for strftime in Bash 4.2+
        printf "%($1)T\n" -1
    }
else
    function lk_date() {
        date +"$1"
    }
fi

# shellcheck disable=SC2162
if lk_bash_at_least 4 1; then
    function lk_pause() {
        read -sN 1 -p "${1:-Press any key to continue . . . }"
        echo
    }
else
    function lk_pause() {
        read -sp "${1:-Press return to continue . . . }"
        echo
    }
fi

function lk_timestamp() {
    lk_date "%s"
}

function lk_is_root() {
    [ "$EUID" -eq "0" ]
}

function lk_is_yes() {
    [[ "$1" =~ ^[yY]$ ]]
}

function lk_is_no() {
    [[ "$1" =~ ^[nN]$ ]]
}

function lk_is_true() {
    [[ "$1" =~ ^([yY1])$ ]]
}

function lk_is_false() {
    [[ "$1" =~ ^([nN0])$ ]]
}

function lk_full_name() {
    getent passwd "${1:-$UID}" | cut -d: -f5 | cut -d, -f1
}

# [ESCAPE=escape_with] lk_escape string [escape_char1...]
function lk_escape() {
    local i=0 STRING="$1" ESCAPE="${ESCAPE:-\\}" SPECIAL SEARCH REPLACE
    shift
    SPECIAL=("$ESCAPE" "$@")
    [ "$ESCAPE" != "\\" ] || ESCAPE="\\\\"
    for REPLACE in "${SPECIAL[@]}"; do
        # ensure ESCAPE itself is only escaped once
        [ "$i" -eq "0" ] || [ "$REPLACE" != "${SPECIAL[0]}" ] || continue
        SEARCH="\\$REPLACE"
        [ "$REPLACE" != "\\" ] || REPLACE="\\\\"
        [ "$REPLACE" != "}" ] || REPLACE="\\}"
        eval "STRING=\"\${STRING//$SEARCH/$ESCAPE$REPLACE}\""
        ((++i))
    done
    echo "$STRING"
}

function lk_escape_ere() {
    # shellcheck disable=SC1003
    lk_escape "$1" '$' '(' ')' '*' '+' '.' '/' '?' '[' '\' ']' '^' '{' '|' '}'
}

function lk_escape_ere_replace() {
    # shellcheck disable=SC1003
    lk_escape "$1" '&' '/' '\'
}

# lk_replace find replace_with string
#   Replace all occurrences of FIND in STRING with REPLACE_WITH.
function lk_replace() {
    echo "${3//$(lk_escape "$1" '*' '?' '[' ']' '(')/$2}"
}

function lk_lower() {
    [ "$#" -gt "0" ] &&
        echo "$*" | tr '[:upper:]' '[:lower:]' ||
        tr '[:upper:]' '[:lower:]'
}

function lk_upper() {
    [ "$#" -gt "0" ] &&
        echo "$*" | tr '[:lower:]' '[:upper:]' ||
        tr '[:lower:]' '[:upper:]'
}

function lk_trim() {
    [ "$#" -gt "0" ] &&
        echo "$1" | sed -Ee 's/^\s+//' -e 's/\s+$//' ||
        sed -Ee 's/^\s+//' -e 's/\s+$//'
}

function lk_get_hostname() {
    hostname -s | lk_lower
}

function lk_safe_tput() {
    # to improve performance, scripts running without a terminal can set LK_ON_TERMINAL=0
    if lk_is_true "${LK_ON_TERMINAL:-1}" && tput "$@" >/dev/null 2>&1; then
        tput "$@"
    fi
}

function lk_get_colours() {
    local PREFIX="${1-LK_}"
    # foreground
    echo "${PREFIX}BLACK=\"\$(lk_safe_tput setaf 0)\""
    echo "${PREFIX}RED=\"\$(lk_safe_tput setaf 1)\""
    echo "${PREFIX}GREEN=\"\$(lk_safe_tput setaf 2)\""
    echo "${PREFIX}YELLOW=\"\$(lk_safe_tput setaf 3)\""
    echo "${PREFIX}BLUE=\"\$(lk_safe_tput setaf 4)\""
    echo "${PREFIX}MAGENTA=\"\$(lk_safe_tput setaf 5)\""
    echo "${PREFIX}CYAN=\"\$(lk_safe_tput setaf 6)\""
    echo "${PREFIX}WHITE=\"\$(lk_safe_tput setaf 7)\""
    echo "${PREFIX}GREY=\"\$(lk_safe_tput setaf 8)\""
    # background
    echo "${PREFIX}BLACK_BG=\"\$(lk_safe_tput setab 0)\""
    echo "${PREFIX}RED_BG=\"\$(lk_safe_tput setab 1)\""
    echo "${PREFIX}GREEN_BG=\"\$(lk_safe_tput setab 2)\""
    echo "${PREFIX}YELLOW_BG=\"\$(lk_safe_tput setab 3)\""
    echo "${PREFIX}BLUE_BG=\"\$(lk_safe_tput setab 4)\""
    echo "${PREFIX}MAGENTA_BG=\"\$(lk_safe_tput setab 5)\""
    echo "${PREFIX}CYAN_BG=\"\$(lk_safe_tput setab 6)\""
    echo "${PREFIX}WHITE_BG=\"\$(lk_safe_tput setab 7)\""
    echo "${PREFIX}GREY_BG=\"\$(lk_safe_tput setab 8)\""
    # other
    echo "${PREFIX}BOLD=\"\$(lk_safe_tput bold)\""
    echo "${PREFIX}DIM=\"\$(lk_safe_tput dim)\""
    echo "${PREFIX}STANDOUT=\"\$(lk_safe_tput smso)\""
    echo "${PREFIX}STANDOUT_OFF=\"\$(lk_safe_tput rmso)\""
    echo "${PREFIX}WRAP=\"\$(lk_safe_tput smam)\""
    echo "${PREFIX}WRAP_OFF=\"\$(lk_safe_tput rmam)\""
    echo "${PREFIX}RESET=\"\$(lk_safe_tput sgr0)\""
}

function lk_maybe_plural() {
    [ "$1" -eq "1" ] && echo "$2" || echo "$3"
}

function lk_echo_array() {
    printf '%s\n' "$@"
}

# lk_echoc [-neE] message [colour_sequence...]
function lk_echoc() {
    local ECHO_ARGS=() MESSAGE RESET IFS COLOURS=
    RESET="$(lk_safe_tput sgr0)"
    while [[ "${1:-}" =~ ^-[neE]+$ ]]; do
        ECHO_ARGS+=("$1")
        shift
    done
    MESSAGE="${1:-}"
    shift || true
    if [ "$#" -gt "0" ] && [ -n "$RESET" ]; then
        IFS=
        COLOURS="$*"
        unset IFS
        MESSAGE="$(lk_replace "$RESET" "$RESET$COLOURS" "$MESSAGE")"
    fi
    echo ${ECHO_ARGS[@]+"${ECHO_ARGS[@]}"} "$COLOURS$MESSAGE$RESET"
}

# lk_console_message message [[secondary_message] colour_sequence]
function lk_console_message() {
    local MESSAGE COLOURS MESSAGE2=
    MESSAGE="${1:-}"
    shift || true
    [ "$#" -le "1" ] || {
        MESSAGE2="$1"
        shift
    }
    COLOURS="${1-$LK_DEFAULT_CONSOLE_COLOUR}"
    echo "$(
        # - atomic unless larger than buffer (smaller of PIPE_BUF, BUFSIZ)
        # - there's no portable way to determine buffer size
        # - writing <=512 bytes with echo or printf should be atomic on all
        #   platforms, but this can't be guaranteed
        lk_echoc -n "==> " "$COLOURS"
        lk_echoc -n "$MESSAGE" "${BOLD:-$(lk_safe_tput bold)}"
        [ -z "$MESSAGE2" ] || lk_echoc -n " $MESSAGE2" "$COLOURS"
    )" >&2
}

# lk_console_item message item [colour_sequence]
function lk_console_item() {
    lk_console_message "${1%:}:" "$2" "${3-$LK_DEFAULT_CONSOLE_COLOUR}"
}

# lk_console_list message [single_noun plural_noun] [colour_sequence]
function lk_console_list() {
    local MESSAGE SINGLE_NOUN PLURAL_NOUN COLOURS ITEM ITEMS=()
    MESSAGE="${1:-}"
    shift || true
    [ "$#" -le "1" ] || {
        SINGLE_NOUN="$1"
        PLURAL_NOUN="$2"
        shift 2
    }
    COLOURS="${1-$LK_DEFAULT_CONSOLE_COLOUR}"
    while IFS= read -r ITEM || [ -n "$ITEM" ]; do
        [ -z "$ITEM" ] || ITEMS+=("$ITEM")
    done
    lk_console_message "${MESSAGE%:}:" "$COLOURS"
    [ "${#ITEMS[@]}" -eq "0" ] || lk_echoc "$(printf '%s\n' "${ITEMS[@]}" | column)" "$COLOURS" >&2
    [ -z "${SINGLE_NOUN:-}" ] || echo "(${#ITEMS[@]} $(lk_maybe_plural "${#ITEMS[@]}" "$SINGLE_NOUN" "$PLURAL_NOUN"))" >&2
}

# lk_add_file_suffix file_path suffix [ext]
#   Add SUFFIX to FILE_PATH without changing FILE_PATH's extension.
#   Use EXT for special extensions like ".tar.gz".
function lk_add_file_suffix() {
    local BASENAME
    BASENAME="$(basename "$1")" || return
    if [ -z "${3:-}" ] && [[ "$BASENAME" =~ .+\..+ ]]; then
        echo "${1%.*}${2}.${1##*.}"
    elif [ -n "${3:-}" ] && eval "[[ \"$BASENAME\" =~ .+${3//./\\.}\$ ]]"; then
        echo "${1%$3}${2}${3}"
    else
        echo "${1}${2}"
    fi
}

# SUDO_OR_NOT=<1|0|Y|N> lk_maybe_sudo command [arg1...]
function lk_maybe_sudo() {
    if lk_is_true "${SUDO_OR_NOT:-0}"; then
        sudo -H "$@"
    else
        "$@"
    fi
}

# lk_safe_symlink target_path link_path [use_sudo [try_default]]
function lk_safe_symlink() {
    local TARGET LINK SUDO_OR_NOT="${3:-${SUDO_OR_NOT:-0}}" TRY_DEFAULT="${4:-0}" CURRENT_TARGET
    TARGET="$1"
    LINK="$2"
    [ -n "$LINK" ] || return
    [ -e "$TARGET" ] || {
        lk_is_true "$TRY_DEFAULT" || return
        TARGET="$(lk_add_file_suffix "$TARGET" "-default")"
        [ -e "$TARGET" ] || return
    }
    ! lk_command_exists realpath || TARGET="$(lk_maybe_sudo realpath -s "$TARGET")"
    LK_SAFE_SYMLINK_NO_CHANGE=
    if lk_maybe_sudo test -L "$LINK"; then
        CURRENT_TARGET="$(lk_maybe_sudo readlink "$LINK")" || return
        [ "$CURRENT_TARGET" != "$TARGET" ] || {
            LK_SAFE_SYMLINK_NO_CHANGE=1
            return
        }
        lk_maybe_sudo rm -f "$LINK" || return
    elif [ -e "$LINK" ]; then
        lk_maybe_sudo mv -fv "$LINK" "$LINK.bak" || return
    else
        lk_maybe_sudo mkdir -pv "$(dirname "$LINK")" || return
    fi
    lk_maybe_sudo ln -sv "$TARGET" "$LINK"
}

function lk_register_gnu_commands() {
    local COMMAND PREFIX=
    ! lk_is_macos || PREFIX="g"
    for COMMAND in "$@"; do
        eval "function gnu_$COMMAND() { $PREFIX$COMMAND \"\$@\"; }"
    done
    LK_GNU_COMMANDS=($(printf '%s\n' ${LK_GNU_COMMANDS[@]+"${LK_GNU_COMMANDS[@]}"} "$@" | sort | uniq))
}

function lk_install_gnu_commands() {
    local COMMANDS=("$@") COMMAND GCOMMAND COMMAND_PATH EXIT_STATUS=0 PREFIX=
    ! lk_is_macos || PREFIX="g"
    [ "$#" -gt "0" ] || COMMANDS=(${LK_GNU_COMMANDS[@]+"${LK_GNU_COMMANDS[@]}"})
    for COMMAND in ${COMMANDS[@]+"${COMMANDS[@]}"}; do
        GCOMMAND="$PREFIX$COMMAND"
        lk_command_exists "$GCOMMAND" ||
            {
                EXIT_STATUS="$?"
                echo "$GCOMMAND: command not found" >&2
                continue
            }
        COMMAND_PATH="$(command -v "$GCOMMAND" 2>/dev/null)" &&
            lk_safe_symlink "$COMMAND_PATH" "${GNU_PATH:-/usr/local/bin}/gnu_$COMMAND" ||
            EXIT_STATUS="$?"
    done
    return "$EXIT_STATUS"
}

function lk_test_many() {
    local TEST="$1" VALUE
    shift
    for VALUE in "$@"; do
        test "$TEST" "$VALUE" || return
    done
}

function lk_paths_exist() {
    [ "$#" -gt "0" ] && lk_test_many "-e" "$@"
}

function lk_files_exist() {
    [ "$#" -gt "0" ] && lk_test_many "-f" "$@"
}

function lk_dirs_exist() {
    [ "$#" -gt "0" ] && lk_test_many "-d" "$@"
}

function lk_sort_paths_by_date() {
    gnu_stat --printf '%Y :%n\0' "$@" | sort -zn | sed -zE 's/^[0-9]+ ://' | xargs -0 printf '%s\n'
}

function lk_sort_paths_by_date_reverse() {
    lk_sort_paths_by_date | tac
}

function lk_is_identifier() {
    [[ "$1" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]
}

function lk_variable_set() {
    declare -p "$1" >/dev/null 2>&1
}

# lk_version_at_least installed_version minimum_version
function lk_version_at_least() {
    local MIN
    MIN="$(printf '%s\n' "$1" "$2" | gnu_sort --version-sort | head -n1 || lk_warn "lk_version_at_least: error sorting versions")" &&
        [ "$MIN" = "$2" ]
}

function lk_return_cached() {
    lk_variable_set "$1" || {
        eval "$1=0;{ $2;}||$1=\"\$?\""
    }
    return "${!1}"
}

function lk_is_macos() {
    lk_return_cached LK_IS_MACOS '[ "$(uname -s)" = "Darwin" ]'
}

function lk_is_linux() {
    lk_return_cached LK_IS_LINUX '[ "$(uname -s)" = "Linux" ]'
}

function lk_is_wsl() {
    lk_return_cached LK_IS_WSL 'lk_is_linux && grep -qi microsoft /proc/version >/dev/null 2>&1'
}

function lk_is_arch() {
    lk_return_cached LK_IS_ARCH 'lk_is_linux && [ -f "/etc/arch-release" ]'
}

function lk_is_ubuntu() {
    lk_return_cached LK_IS_UBUNTU 'lk_is_linux && lk_command_exists lsb_release && [ "$(lsb_release -si)" = "Ubuntu" ]'
}

function lk_is_ubuntu_lts() {
    lk_return_cached LK_IS_UBUNTU_LTS 'lk_is_ubuntu && lk_command_exists ubuntu-distro-info && ubuntu-distro-info --supported-esm | grep -Fx "$(lsb_release -sc)" >/dev/null 2>&1'
}

function lk_ubuntu_at_least() {
    lk_is_ubuntu && lk_version_at_least "$(lsb_release -sr)" "$1"
}

function lk_is_desktop() {
    lk_return_cached LK_IS_DESKTOP 'lk_is_macos || lk_command_exists X'
}

function lk_is_server() {
    ! lk_is_desktop
}

function lk_get_gpg_keyids() {
    gpg --list-keys --with-colons | { grep -E '^(pub|sub):' || true; } | cut -d: -f5
}

# lk_start_or_restart command [arg1...]
#   Kill any running COMMAND processes, then run COMMAND in the
#   background and disown it.
function lk_start_or_restart() {
    local COMMAND
    [ -n "$1" ] &&
        COMMAND="$(basename "$1")" || return
    is_root ||
        ! pgrep -xu "$USER" "$COMMAND" >/dev/null || # limit to processes owned by $USER
        pkill -xu "$USER" "$COMMAND"                 #
    ! is_root ||                                     #
        ! pgrep -x "$COMMAND" >/dev/null ||          # ...unless we're running as root
        pkill -x "$COMMAND"
    ! command_exists "$1" || {
        nohup "$@" </dev/null >/dev/null 2>&1 &
        disown
    }
}

# lk_apply_setting file_path setting_name setting_value [delimiter] [comment_chars] [space_chars]
# shellcheck disable=SC2005
function lk_apply_setting() {
    local FILE_PATH="$1" SETTING_NAME="$2" SETTING_VALUE="$3" DELIMITER="${4:-=}" \
        COMMENT_PATTERN SPACE_PATTERN NAME_ESCAPED VALUE_ESCAPED DELIMITER_ESCAPED CHECK_PATTERN SEARCH_PATTERN REPLACE REPLACED
    COMMENT_PATTERN="${5:+[$(lk_escape_ere "$5")]*}"
    SPACE_PATTERN="${6:+[$(lk_escape_ere "$6")]*}"
    NAME_ESCAPED="$(lk_escape_ere "$SETTING_NAME")"
    VALUE_ESCAPED="$(lk_escape_ere "$SETTING_VALUE")"
    DELIMITER_ESCAPED="$(lk_trim "$DELIMITER")"
    [ -n "$DELIMITER_ESCAPED" ] || DELIMITER_ESCAPED="$DELIMITER"
    DELIMITER_ESCAPED="$(lk_escape_ere "$DELIMITER_ESCAPED")"
    CHECK_PATTERN="^$NAME_ESCAPED$SPACE_PATTERN$DELIMITER_ESCAPED$SPACE_PATTERN$VALUE_ESCAPED$SPACE_PATTERN\$"
    grep -Eq "$CHECK_PATTERN" "$FILE_PATH" || {
        REPLACE="$SETTING_NAME$DELIMITER$SETTING_VALUE"
        # try to replace an uncommented value first
        SEARCH_PATTERN="^$SPACE_PATTERN$NAME_ESCAPED$SPACE_PATTERN$DELIMITER_ESCAPED.*\$"
        REPLACED="$(sed -E "0,/$SEARCH_PATTERN/{s/$SEARCH_PATTERN/$(lk_escape_ere_replace "$REPLACE")/}" "$FILE_PATH")" || return
        # failing that, try for a commented one
        grep -Eq "$CHECK_PATTERN" <<<"$REPLACED" || {
            SEARCH_PATTERN="^$COMMENT_PATTERN$SPACE_PATTERN$NAME_ESCAPED$SPACE_PATTERN$DELIMITER_ESCAPED.*\$"
            REPLACED="$(sed -E "0,/$SEARCH_PATTERN/{s/$SEARCH_PATTERN/$(lk_escape_ere_replace "$REPLACE")/}" "$FILE_PATH")" || return
        }
        [ -f "$FILE_PATH.orig" ] || lk_maybe_sudo cp -pv "$FILE_PATH" "$FILE_PATH.orig" || return
        if grep -Eq "$CHECK_PATTERN" <<<"$REPLACED"; then
            lk_maybe_sudo tee "$FILE_PATH" <<<"$REPLACED" >/dev/null || return
        else
            {
                echo "$REPLACED"
                echo "$REPLACE"
            } | lk_maybe_sudo tee "$FILE_PATH" >/dev/null || return
        fi
    }
}

# EXPAND_WHITESPACE=<1|0|Y|N> lk_enable_entry file_path entry [comment_chars] [trailing_pattern]
#   If TRAILING_PATTERN is unset, trailing whitespace (followed by an optional
#   comment if COMMENT_CHARS is set) will be matched after ENTRY.
#   EXPAND_WHITESPACE is enabled by default and allows one or more whitespace characters
#   in ENTRY to match one or more whitespace characters in FILE_PATH. Escaped whitespace
#   characters in ENTRY are unescaped without expansion.
function lk_enable_entry() {
    local FILE_PATH="$1" ENTRY="$2" OPTIONAL_COMMENT_PATTERN COMMENT_PATTERN TRAILING_PATTERN \
        ENTRY_ESCAPED CHECK_PATTERN SEARCH_PATTERN REPLACED
    OPTIONAL_COMMENT_PATTERN="${3:+[$(lk_escape_ere "$3")]*}"
    COMMENT_PATTERN="${3:+${3// /}}"
    COMMENT_PATTERN="${COMMENT_PATTERN:+[$(lk_escape_ere "$COMMENT_PATTERN")]+}"
    TRAILING_PATTERN="${4-\\s+${COMMENT_PATTERN:+(${COMMENT_PATTERN}.*)?}}"
    ENTRY_ESCAPED="$(lk_escape_ere "$ENTRY")"
    lk_is_false "${EXPAND_WHITESPACE:-1}" || ENTRY_ESCAPED="$(sed -Ee 's/(^|[^\])\s+/\1\\s+/g' -e 's/\\\\(\s)/\1/g' <<<"$ENTRY_ESCAPED")"
    CHECK_PATTERN="^$ENTRY_ESCAPED${TRAILING_PATTERN:+($TRAILING_PATTERN)?}\$"
    grep -Eq "$CHECK_PATTERN" "$FILE_PATH" || {
        # try to replace a commented entry
        SEARCH_PATTERN="^$OPTIONAL_COMMENT_PATTERN($ENTRY_ESCAPED${TRAILING_PATTERN:+($TRAILING_PATTERN)?})\$"
        REPLACED="$(sed -E "0,/$SEARCH_PATTERN/{s/$SEARCH_PATTERN/\1/}" "$FILE_PATH")" || return
        [ -f "$FILE_PATH.orig" ] || lk_maybe_sudo cp -pv "$FILE_PATH" "$FILE_PATH.orig" || return
        if grep -Eq "$CHECK_PATTERN" <<<"$REPLACED"; then
            lk_maybe_sudo tee "$FILE_PATH" <<<"$REPLACED" >/dev/null || return
        else
            {
                echo "$REPLACED"
                echo "$ENTRY"
            } | lk_maybe_sudo tee "$FILE_PATH" >/dev/null || return
        fi
    }
}

# lk_disable_entry file_path entry_pattern comment_chars [trailing_pattern]
#   ENTRY_PATTERN must be properly escaped. The first character in COMMENT_CHARS
#   is prepended to any matching entries.
function lk_disable_entry() {
    local FILE_PATH="$1" ENTRY_PATTERN="$2" COMMENT_CHAR COMMENT_PATTERN TRAILING_PATTERN \
        CHECK_PATTERN REPLACED
    [ -n "$3" ] || return
    COMMENT_CHAR="${3:0:1}"
    COMMENT_PATTERN="[$(lk_escape_ere "$3")]*"
    TRAILING_PATTERN="${4-(\\s+$COMMENT_PATTERN.*)?}"
    CHECK_PATTERN="^$ENTRY_PATTERN$TRAILING_PATTERN\$"
    ! grep -Eq "$CHECK_PATTERN" "$FILE_PATH" || {
        REPLACED="$(sed -E "s/$CHECK_PATTERN/$(lk_escape_ere_replace "$COMMENT_CHAR")&/" "$FILE_PATH")" || return
        if ! grep -Eq "$CHECK_PATTERN" <<<"$REPLACED"; then
            [ -f "$FILE_PATH.orig" ] || lk_maybe_sudo cp -pv "$FILE_PATH" "$FILE_PATH.orig" || return
            lk_maybe_sudo tee "$FILE_PATH" <<<"$REPLACED" >/dev/null || return
        else
            lk_warn "unable to disable entry in $FILE_PATH"
            return 1
        fi
    }
}

function lk_load_env() {
    local i j DELIMITED_PATH IFS ADD ADD_FIRST ADD_TO_PATH=(${ADD_TO_PATH[@]+"${ADD_TO_PATH[@]}"} "$LK_ROOT/bin") ADD_TO_PATH_FIRST=("$HOME/.local/bin" ${ADD_TO_PATH_FIRST[@]+"${ADD_TO_PATH_FIRST[@]}"})
    ! lk_is_macos || ADD_TO_PATH+=("$LK_ROOT/bin/macos")
    ! lk_is_linux || ADD_TO_PATH+=("$LK_ROOT/bin/linux")
    ! lk_is_arch || ADD_TO_PATH+=("$LK_ROOT/bin/arch")
    ! lk_is_ubuntu || ADD_TO_PATH+=("$LK_ROOT/bin/ubuntu")
    DELIMITED_PATH=":$PATH:"
    for j in ADD_TO_PATH ADD_TO_PATH_FIRST; do
        eval "for i in \"\${!$j[@]}\"; do
            [ -d \"\${$j[\$i]}\" ] && [ \"\${DELIMITED_PATH//:\${$j[\$i]}:/}\" = \"\$DELIMITED_PATH\" ] ||
                unset \"$j[\$i]\"
        done"
    done
    IFS=:
    ADD="${ADD_TO_PATH[*]+${ADD_TO_PATH[*]}}"
    ADD_FIRST="${ADD_TO_PATH_FIRST[*]+${ADD_TO_PATH_FIRST[*]}}"
    unset IFS
    [ -z "$ADD$ADD_FIRST" ] || {
        echo "export PATH=\"${ADD_FIRST:+$ADD_FIRST:}\$PATH${ADD:+:$ADD}\""
    }
    ! lk_is_linux || lk_is_root || ! EXPORT_LINUXBREW="$(lk_load_linuxbrew)" || {
        echo "$EXPORT_LINUXBREW"
    }
    lk_is_root || [ -z "${SCREENSHOT_DIR:-}" ] || {
        { [ -d "$SCREENSHOT_DIR" ] || mkdir -pv "$SCREENSHOT_DIR"; } &&
            echo "export LK_SCREENSHOT_DIR=\"$SCREENSHOT_DIR\""
    }
}

# lk_user_in_group username groupname...
#   True if USERNAME belongs to at least one of GROUPNAME.
function lk_user_in_group() {
    [ "$(comm -12 <(groups "$1" | sed -E 's/^.*://' | grep -Eo '[^[:space:]]+' | sort) <(lk_echo_array "${@:2}" | sort | uniq) | wc -l)" -gt "0" ]
}

# lk_make_iso path1...
function lk_make_iso() {
    local ISOFILE
    lk_paths_exist "$@" || lk_warn "lk_make_iso path1..." || return
    ISOFILE="$(basename "$1").iso" &&
        [ ! -e "$ISOFILE" ] ||
        lk_warn "$ISOFILE already exists" ||
        return
    mkisofs -J -o "$ISOFILE" "$@"
}

set -o pipefail

# coreutils
#   [ arch b2sum base32 base64 basename cat chcon chgrp chmod chown
#   chroot cksum comm cp csplit cut date dd df dir dircolors dirname du
#   echo env expand expr factor false fmt fold groups head hostid id
#   install join link ln logname ls md5sum md5sum.textutils mkdir mkfifo
#   mknod mktemp mv nice nl nohup nproc numfmt od paste pathchk pinky pr
#   printenv printf ptx pwd readlink realpath rm rmdir runcon seq
#   sha1sum sha224sum sha256sum sha384sum sha512sum shred shuf sleep
#   sort split stat stdbuf stty sum sync tac tail tee test timeout touch
#   tr true truncate tsort tty uname unexpand uniq unlink users vdir wc
#   who whoami yes
lk_register_gnu_commands date ln mktemp sort stat

# gawk, findutils, grep, netcat, sed, tar
lk_register_gnu_commands awk find grep nc sed tar

! lk_is_linux || {

    function lk_load_linuxbrew() {
        local PREFIX="${1:-/home/linuxbrew/.linuxbrew}"
        [ -d "$PREFIX" ] || return
        cat <<EOF
export HOMEBREW_PREFIX="$PREFIX"
export HOMEBREW_CELLAR="$PREFIX/Cellar"
export HOMEBREW_REPOSITORY="$PREFIX/Homebrew"
export PATH="\${PATH:+\$PATH:}$PREFIX/bin:$PREFIX/sbin"
export MANPATH="\${MANPATH:+\$MANPATH:}$PREFIX/share/man:"
export INFOPATH="\${INFOPATH:+\$INFOPATH:}$PREFIX/share/info"
lk_brew_wrap() (
    eval "\$("$PREFIX/bin/brew" shellenv)"
    "\$@"
)
brew() {
    lk_brew_wrap "$PREFIX/bin/brew" "\$@"
}
EOF
    }

    function lk_check_ext4() {
        local PAIRS SOURCE TARGET FSTYPE SIZE AVAIL
        findmnt -Pt ext4,ext3,ext2 -o SOURCE,TARGET,FSTYPE,SIZE,AVAIL | while IFS= read -r PAIRS; do
            eval "$PAIRS"
            lk_console_item "Mounted $FSTYPE filesystem found at:" "$SOURCE"
            sudo tune2fs -l "$SOURCE" | command grep -Ei '(filesystem state|mount count|last checked):'
            lk_echoc "($SIZE with $AVAIL available, mounted at $TARGET)" "${YELLOW:-$(lk_safe_tput setaf 3)}"
            echo
        done
    }

    function lk_check_sysctl() {
        lk_console_message "IPv4 and IPv6"
        sysctl -ar 'net\..*\.(((default|all)\.rp_filter|tcp_syncookies|ip_forward|all\.forwarding)|accept_ra)$'
    }

}

! lk_is_arch || {

    function lk_makepkg() {
        makepkg --syncdeps --rmdeps --clean --install &&
            makepkg --printsrcinfo >.SRCINFO
    }

}

LK_DEFAULT_CONSOLE_COLOUR="$(lk_safe_tput setaf 6)"
