#!/bin/bash
# shellcheck disable=SC2034,SC2206,SC2207,SC1090,SC2162

set -euo pipefail

function error_trap() {

    echo "Error: $(basename "$0") failed with exit code $1 in $2 at line $3" >&2
    exit "$1"

}

function exit_trap() {

    local i

    for i in "${!DELETE_ON_EXIT[@]}"; do

        rm -Rf "${DELETE_ON_EXIT[$i]}" || true

    done

    for i in "${!KILL_ON_EXIT[@]}"; do

        kill "${KILL_ON_EXIT[$i]}" || true

    done

}

# Reviewed: 2019-10-28
function gnu_command() {

    local COMMAND

    COMMAND="$1"
    shift

    if is_macos; then

        if command_exists "g${COMMAND}"; then

            COMMAND="g${COMMAND}"

        else

            die "$(basename "$0") requires g${COMMAND} (have you installed Homebrew coreutils?)"

        fi

    fi

    "$COMMAND" "$@"

}

# Reviewed: 2019-10-28
function register_gnu_commands() {

    local COMMAND

    for COMMAND in "$@"; do

        eval 'function gnu_'"$COMMAND"'() { gnu_command '"$COMMAND"' "$@"; }'

    done

}

# Reviewed: 2019-10-28
function install_gnu_commands() {

    local COMMAND GNU_COMMAND COMMAND_PATH

    for COMMAND in "$@"; do

        GNU_COMMAND="gnu_${COMMAND}"

        ! is_macos || COMMAND="g${COMMAND}"

        if COMMAND_PATH="$(command -v "$COMMAND" 2>/dev/null)"; then

            safe_symlink "$COMMAND_PATH" "/usr/local/bin/$GNU_COMMAND" || return

        else

            echo "WARNING: GNU command ${BOLD}${COMMAND}${RESET} doesn't exist" >&2

        fi

    done

}

function is_virtual() {

    assert_is_linux

    grep -Eq '^flags\s*:.*\shypervisor(\s|$)' /proc/cpuinfo

}

# Reviewed: 2019-11-06
function is_desktop() {

    assert_is_linux

    local CHASSIS_TYPE PORTABLE_CHASSIS_TYPES=(

        # Portable
        8

        # Laptop
        9

        # Notebook
        10

        # Hand Held
        11

        # Sub Notebook
        14

    )

    CHASSIS_TYPE="$(</sys/class/dmi/id/chassis_type)" || die

    [ -n "$CHASSIS_TYPE" ] || die "No chassis type"

    ! printf '%s\n' "${PORTABLE_CHASSIS_TYPES[@]}" | grep "^${CHASSIS_TYPE}\$" >/dev/null

}

# Reviewed: 2019-11-12
function is_lid_closed() {

    assert_is_linux

    grep -q 'closed$' /proc/acpi/button/lid/*/state

}

function assert_is_macos() {

    is_macos || die "Error: $(basename "$0") is not supported on this platform (macOS required)"

}

function is_macos() {

    [ "$IS_MACOS" -eq "1" ]

}

function assert_is_windows() {

    is_windows || die "Error: $(basename "$0") is not supported on this platform (Windows required)"

}

function is_windows() {

    [ "$IS_WSL" -eq "1" ]

}

function assert_is_linux() {

    is_linux || die "Error: $(basename "$0") is not supported on this platform (Linux required)"

}

function is_linux() {

    [ "$IS_LINUX" -eq "1" ]

}

# Reviewed: 2019-12-18
function assert_is_ubuntu() {
    is_ubuntu || die "$(basename "$0") requires Ubuntu"
}

function is_ubuntu() {
    [ "$IS_UBUNTU" -eq "1" ]
}

# Reviewed: 2019-12-18
function assert_is_desktop() {
    has_gui || die "$(basename "$0") requires a desktop environment"
}

# Reviewed: 2019-12-18
function assert_is_server() {
    ! has_gui || die "$(basename "$0") requires a server environment"
}

function has_gui() {
    [ "$HAS_GUI" -eq "1" ]
}

# Reviewed: 2019-12-18
function assert_is_ubuntu_lts() {
    is_ubuntu_lts || die "$(basename "$0") is only supported on LTS releases of Ubuntu"
}

# Reviewed: 2019-12-18
function is_ubuntu_lts() {
    is_ubuntu || return
    assert_command_exists ubuntu-distro-info
    ubuntu-distro-info --supported-esm | grep ^"$DISTRIB_CODENAME"$ >/dev/null 2>&1
}

function assert_root() {

    is_root || die "Error: $(basename "$0") must be run as the superuser"

}

function assert_not_root() {

    ! is_root || die "Error: $(basename "$0") can't be run as the superuser"

}

function assert_command_exists() {

    command_exists "$1" || die "Error: $(basename "$0") requires $1"

}

function assert_function_exists() {

    function_exists "$1" || die "Error: $(basename "$0") requires Bash function $1"

}

function assert_variable_exists() {

    variable_exists "$1" || die "Error: $(basename "$0") requires variable $1"

}

function is_root() {

    [ "$EUID" -eq "0" ]

}

# the relevant function mustn't depend on other functions
function sudo_function() {

    local FUNCTION

    FUNCTION="$1"
    shift

    sudo bash -c "$(declare -f "$FUNCTION"); $FUNCTION \"\$@\"" "$0" "$@"

}

# Usage: filename_maybe_add_extension "/path/to/file" ".pdf"
# (output would be "/path/to/file.ext.pdf")
function filename_maybe_add_extension() {

    local FILENAME BASENAME

    FILENAME="$1"
    BASENAME="$(basename "$1")" || die

    [[ "$BASENAME" =~ .+\..+ ]] && [ "$(lower ".${1##*.}")" = "$(lower "$2")" ] || FILENAME="${1}${2}"

    echo "$FILENAME"

}

# Usage: filename_add_suffix "/path/to/file.ext" "_backup"
# (output would be "/path/to/file_backup.ext")
function filename_add_suffix() {

    local BASENAME

    BASENAME="$(basename "$1")" || die

    if [[ "$BASENAME" =~ .+\..+ ]]; then

        echo "${1%.*}${2}.${1##*.}"

    else

        echo "${1}${2}"

    fi

}

# filename_get_next_backup: filename_get_next_backup filename [backup-identifier]
function filename_get_next_backup() {

    local i=0 BACKUP_PATH

    BACKUP_PATH="$(filename_add_suffix "$1" "${2:+_$2}_backup")"

    while [ -e "$BACKUP_PATH" ]; do

        BACKUP_PATH="$(filename_add_suffix "$1" "${2:+_$2}_$((++i))_backup")"

    done

    echo "$BACKUP_PATH"

}

function file_mime_type() {

    [ -f "$1" ] || die "$1 isn't a file"

    file -b --mime-type "$1" || die

}

function is_pdf() {

    local MIME_TYPE

    MIME_TYPE="$(file_mime_type "$1")" || die
    [ "$MIME_TYPE" = "application/pdf" ]

}

# returns non-zero if any of the arguments aren't directories
function are_directories() {

    local DIR

    for DIR in "$@"; do

        [ -d "$DIR" ] || return

    done

    return

}

# returns non-zero if any of the arguments aren't files
function are_files() {

    local FILE

    for FILE in "$@"; do

        [ -f "$FILE" ] || return

    done

    return

}

function command_exists() {

    command -v "$1" >/dev/null 2>&1

}

function function_exists() {

    declare -F "$1" >/dev/null 2>&1

}

function variable_exists() {

    declare -p "$1" >/dev/null 2>&1

}

function user_exists() {

    id "$1" >/dev/null 2>&1

}

function is_bool() {

    [[ "$1" =~ ^(true|false)$ ]]

}

function is_int() {

    [[ "$1" =~ ^[0-9]+$ ]]

}

function is_url() {

    # TODO: replace with uri_get_parts regex
    gnu_grep -Pq '\b(([\w-]+://?|www[.])[^\s()<>]+(?:\([\w\d]+\)|([^[:punct:]\s]|/)))' <<<"$1"

}

# deprecated
function echocn() {

    deprecated_warning "echocn" "echoc -n [arg ...]"
    echoc -n "$@"

}

function echoc() {
    lc_echoc "$@"
}

# Reviewed: 2019-11-04
function die() {

    [ "$#" -eq "0" ] || echoc "$@" >&2

    [ "${MUST_DIE_HAPPY:-N}" = "Y" ] || exit 1

    exit 0

}

# Reviewed: 2019-11-04
function die_happy() {

    [ "$#" -eq "0" ] || echoc "$@" >&2

    exit 0

}

# Reviewed: 2019-11-29
function deprecated_warning() {

    [ "${NO_DEPRECATED_WARNINGS:-N}" = "Y" ] ||
        echoc -e "\nWARNING: $1 is deprecated${2:+, please use: $2}\n" "$BOLD$YELLOW" >&2

}

# Usage: version_at_least <installed-version> <minimum-version>
function version_at_least() {

    local MINIMUM

    MINIMUM="$(printf '%s\n' "$1" "$2" | gnu_sort -V | head -n1)" || die
    [ "$MINIMUM" = "$2" ]

}

# Reviewed: 2019-12-16
function pause() {

    # shellcheck disable=SC2162
    read -sN 1 -p "${1:-Press any key to continue . . . }"
    echo

}

# console_message: console_message message [entity_list [colour_sequence ...] ]
#
# Output MESSAGE on the standard output, followed by a list of entities.
# Apply colour control sequences to improve readability.
#
# Output is one of the following:
#
# multiple entities
#     >
#     > ==> MESSAGE:
#     > ENTITIES...
#     >
#
# one entity
#     ==> MESSAGE: ENTITY
#
# no entities
#     ==> MESSAGE
#
# On interactive terminals, MESSAGE is bold and colour control sequences
# are applied to "==>", entities, and any MESSAGE text surrounded by
# __double underscores__.
#
# If MESSAGE contains a trailing colon, it is removed. Entities are
# piped to `column`.
#
function console_message() {

    local MESSAGE1 MESSAGE2 MESSAGE2_COUNT OUTPUT

    MESSAGE1="${1%:}"
    MESSAGE2=(${2:-})
    shift || die
    shift || true

    MESSAGE2_COUNT="${#MESSAGE2[@]}"

    [ "$MESSAGE2_COUNT" -eq "0" ] || MESSAGE1="${MESSAGE1}:"

    OUTPUT=$(

        echoc -n "==> " "$@"
        echoc -n "$MESSAGE1" "$BOLD"

        # case statements don't parse in Bash 3.2.57 subshells
        if [ "$MESSAGE2_COUNT" -eq "0" ]; then

            :

        elif [ "$MESSAGE2_COUNT" -eq "1" ]; then

            echoc " ${MESSAGE2[0]}" "$@"

        else

            echo
            echoc "$(printf '%s\n' "${MESSAGE2[@]}" | column)" "$@"

        fi

    )

    if [ "$MESSAGE2_COUNT" -gt "1" ]; then

        printf '\n%s\n\n' "$OUTPUT"

    else

        echo "$OUTPUT"

    fi

}

function console_warning() {

    console_message "$@" >&2

}

function get_enter() {

    local PROMPT REPLY

    PROMPT="${1:-Press Enter to continue}"
    read -rsp "$PROMPT"

}

function get_value() {

    local PROMPT=() DEFAULT="${2:-}" VALUE

    PROMPT+=("$1")

    [ -z "$DEFAULT" ] || PROMPT+=("[$DEFAULT]")

    read -rp "${PROMPT[*]} " VALUE

    [ -n "$VALUE" ] || VALUE="$DEFAULT"

    echo "$VALUE"

}

# Usage: get_confirmation "Do this?" [default response (y/n)] [force valid response? (y/N)] && { do_it; }
function get_confirmation() {

    local PROMPT=() DEFAULT="${2:-}" FORCE="${3:-N}" YN

    [ -z "$1" ] || PROMPT+=("$1")

    case "$DEFAULT" in

    Y)
        PROMPT+=("[Y/n]")
        ;;

    N)
        PROMPT+=("[y/N]")
        ;;

    *)
        PROMPT+=("[y/n]")
        DEFAULT=
        ;;

    esac

    while :; do

        read -rp "${PROMPT[*]} " YN

        [ -n "$YN" ] || YN="$DEFAULT"

        YN="$(upper "$YN")"

        if [ "$FORCE" != "Y" ] || [[ "$YN" =~ ^(Y|YES|N|NO)$ ]]; then

            break

        fi

    done

    [[ "$YN" =~ ^(Y|YES)$ ]]

}

# Usage: file_to_array "/path/to/file" [exclude-pattern...]
#
# If "/path/to/file" doesn't exist, "/path/to/file-default" is tried.
#
# The following are excluded by default:
# - lines that are empty or only contain whitespace: /^\s*$/
# - comments (lines that start with "#" or ";"): /^[#;]/
#
# To include all lines: file_to_array "/path/to/file" ""
function file_to_array() {

    local FILENAME LINE COMMAND=(cat) EXCLUDE=('^\s*$' '^[#;]')

    FILENAME="${1:-}"
    [ -n "$FILENAME" ] || die "Filename required"
    shift

    if [ "$#" -gt "0" ]; then

        EXCLUDE=("$@")

    fi

    FILE_TO_ARRAY=()
    FILE_TO_ARRAY_FILENAME=

    if [ ! -e "$FILENAME" ]; then

        FILENAME="${FILENAME}-default"

    fi

    if [ -e "$FILENAME" ]; then

        FILE_TO_ARRAY_FILENAME="$(realpath "$FILENAME")" || die

        if [ "${#EXCLUDE[@]}" -gt "1" ] || [ -n "${EXCLUDE[0]}" ]; then

            COMMAND=(grep -Ev "($(array_join_by ")|(" "${EXCLUDE[@]}"))")

        fi

        while IFS= read -r LINE || [ -n "$LINE" ]; do

            FILE_TO_ARRAY+=("$LINE")

        done < <("${COMMAND[@]}" "$FILENAME" || true)

    fi

}

# Usage: single_or_plural <number> "singular noun" "plural noun"
function single_or_plural() {

    if [ "$1" -eq "1" ]; then

        echo "$2"

    else

        echo "$3"

    fi

}

function upper_first() {

    echo "$(echo "$1" | cut -c1 | tr "[:lower:]" "[:upper:]")$(echo "$1" | cut -c2-)"

}

function lower() {

    echo "$1" | tr "[:upper:]" "[:lower:]"

}

function upper() {

    echo "$1" | tr "[:lower:]" "[:upper:]"

}

# Searches the array (must be global, passed by name) for the given value and outputs the first corresponding key if found.
# Plays nicely with globs and sparse arrays. Outputs nothing and exits non-zero if the value isn't found.
#
# Usage: array_search "needle" HAYSTACK_NAME [allow globbing? (Y/n)]
# Reviewed: 2019-11-04
function array_search() {

    local GLOBBING="${3:-Y}" KEYS VALUE i

    eval "KEYS=\"\${!$2[@]}\""

    # two loops = faster than testing GLOBBING inside the loop
    if [ "$GLOBBING" = "Y" ]; then

        for i in $KEYS; do

            eval "VALUE=\"\${$2[$i]}\""

            # shellcheck disable=SC2053
            if [[ "$1" == $VALUE ]] || [[ "$VALUE" == $1 ]]; then

                echo "$i"
                return

            fi

        done

    else

        for i in $KEYS; do

            eval "VALUE=\"\${$2[$i]}\""

            if [ "$1" = "$VALUE" ]; then

                echo "$i"
                return

            fi

        done

    fi

    return 1

}

# Usage: in_array "needle" HAYSTACK_NAME [allow globbing? (y/N)]
# Reviewed: 2019-11-04
function in_array() {

    array_search "$1" "$2" "${3:-N}" >/dev/null

}

# Usage: array_join_by ":" "${MY_ARRAY[@]}"
# Reviewed: 2019-11-11
function array_join_by() {

    local SEP ARR

    SEP="$1"
    shift

    if [ "$#" -gt "0" ]; then

        ARR=("${@/#/$SEP}")
        ARR[0]="$1"
        printf '%s' "${ARR[@]}"

    fi

}

# Usage: array_join_oxford "${MY_ARRAY[@]}"
function array_join_oxford() {

    local THREE_OR_MORE=0

    echo -n "${1:-}"
    shift

    while [ "$#" -gt "1" ]; do

        THREE_OR_MORE=1
        echo -n ", $1"
        shift

    done

    [ "$THREE_OR_MORE" -eq "0" ] || echo -n ','
    [ "$#" -eq "0" ] || echo -n " and $1"

}

# Usage: sort_words "these words need sorting"
# (output would be "need sorting these words")
# Reviewed: 2019-11-18
function sort_words() {

    local WORDS

    WORDS=(${1:-})

    [ "${#WORDS[@]}" -eq "0" ] || {
        WORDS=($(printf '%s\n' "${WORDS[@]}" | sort | uniq))
        echo "${WORDS[*]}"
    }

}

function has_argument() {

    in_array "$1" ORIGINAL_ARGUMENTS

}

function is_autostart() {

    has_argument "--autostart"

}

function offer_sudo_password_bypass() {

    local VERBOSE="${1:-N}" USERNAME="${SUDO_USER:-$USER}" FILENAME CHECK_FILENAME

    # don't proceed if there's no point
    if ! groups "$USERNAME" | grep -Eo '[^:]+$' | grep -E '(\s|^)(admin|sudo)(\s|$)' >/dev/null; then

        [ "$VERBOSE" = "Y" ] && console_message "User ${BOLD}${USERNAME}${RESET} is not an administrator" "" "$BOLD" "$RED" || true
        return

    fi

    FILENAME="/etc/sudoers.d/nopasswd-$USERNAME"
    CHECK_FILENAME="$CACHE_DIR/.nopasswd-$USERNAME"

    if [ -e "$CHECK_FILENAME" ]; then

        [ "$VERBOSE" = "Y" ] && console_message "Password bypass previously enabled for user ${BOLD}${USERNAME}${RESET}" "" "$GREEN" || true
        return

    fi

    console_message "Please provide your computer password if requested" "" "$CYAN"

    # check that we can, in fact, sudo as root
    if ! sudo true; then

        [ "$VERBOSE" = "Y" ] && console_message "User ${BOLD}${USERNAME}${RESET} is not allowed to sudo as root" "" "$BOLD" "$RED" || true
        return

    fi

    if ! sudo test -e "$FILENAME"; then

        if get_confirmation "Allow user ${BOLD}${USERNAME}${RESET} to skip future password prompts?" Y Y; then

            sudo tee "$FILENAME" >/dev/null <<<"${USERNAME} ALL=(ALL) NOPASSWD:ALL" && sudo chmod 0440 "$FILENAME" || die
            console_message "Password bypass enabled for user ${BOLD}${USERNAME}${RESET} in:" "$FILENAME" "$BOLD" "$BLUE"

        else

            return

        fi

    elif [ "$VERBOSE" = "Y" ]; then

        console_message "Password bypass previously enabled for user ${BOLD}${USERNAME}${RESET}" "" "$GREEN"

    fi

    # attempt to save time next time
    { touch "$CHECK_FILENAME" || sudo touch "$CHECK_FILENAME"; } >/dev/null 2>&1 || true

}

# Reviewed: 2019-11-01
function escape_separators() {

    local ARG

    ARG="$1" || die

    ARG="${ARG// /\\ }"
    ARG="${ARG//$'\t'/$'\\\t'}"
    ARG="${ARG//$'\n'/$'\\\n'}"

    printf '%s' "$ARG"

}

# Usage: sed_escape_search "text to escape" [extended regular expressions? (Y/n)]
# Reviewed: 2019-11-01
function sed_escape_search() {

    local ESCAPE EXTENDED="${2:-Y}"

    ESCAPE="$1" || die

    if [ "$EXTENDED" != "N" ]; then

        # shellcheck disable=SC2016
        gnu_sed 's/[]$()*+./?\^{|}[]/\\&/g' <<<"$ESCAPE"

    else

        gnu_sed 's/[]$*./\^[]/\\&/g' <<<"$ESCAPE"

    fi

}

# Reviewed: 2019-11-01
function sed_escape_replace() {

    local ESCAPE ESCAPED

    ESCAPE="$1" || die

    ESCAPED="$(gnu_sed 's/[\/&]/\\&/g' <<<"$ESCAPE")"
    printf '%s' "${ESCAPED//$'\n'/\\n}"

}

# Usage: search_replace "find" "replace with" "string"
# Reviewed: 2019-11-01
function search_replace() {

    local FIND REPLACE

    FIND="$(sed_escape_search "$1")"
    REPLACE="$(sed_escape_replace "$2")"

    gnu_sed -E "s/${FIND}/${REPLACE}/g" <<<"$3"

}

function date_get_log() {

    date +'%b %_d %H:%M:%S %z'

}

function date_get_log_nano() {

    gnu_date +'%b %_d %H:%M:%S.%N %z'

}

function date_get_ymdhms() {

    date +'%Y%m%d%H%M%S'

}

function date_get_timestamp() {

    date +'%s'

}

# Reviewed: 2019-11-30
function url_decode() {

    echo -e "${*//%/\\x}"

}

# Results are returned in document order without de-duplication.
#
# Usage: get_urls_from_url "http://url.to/page-with-urls" [regex to limit results...]
# Reviewed: 2019-11-11
function get_urls_from_url() {

    local TEMP_FILE URLS PATTERN

    TEMP_FILE="$(create_temp_file)"

    wget --quiet --convert-links --output-document "$TEMP_FILE" "$1" || {
        rm -f "$TEMP_FILE" || true
        die
    }

    shift

    # `scheme:` is required (otherwise pretty much everything would be a 'URL')
    URLS="$(grep -Eo '\b(([a-zA-Z][-a-zA-Z0-9+.]*):)(//(([-a-zA-Z0-9._~%!$&'"'"'()*+,;=]+)(:([-a-zA-Z0-9._~%!$&'"'"'()*+,;=]*))?@)?([-a-zA-Z0-9._~%!$&'"'"'()*+,;=]+|\[([0-9a-fA-F:]+)\])(:([0-9]+))?)?([-a-zA-Z0-9._~%!$&'"'"'()*+,;=:@/]+)?(\?([-a-zA-Z0-9._~%!$&'"'"'()*+,;=:@?/]+))?(#([-a-zA-Z0-9._~%!$&'"'"'()*+,;=:@?/]*))?\b' "$TEMP_FILE")" || true

    rm -f "$TEMP_FILE"

    for PATTERN in "$@"; do

        URLS="$(echo "$URLS" | grep -E "$PATTERN")" || true

    done

    echo "$URLS"

}

# Usage: uri_get_parts "any://valid.uri?with=any#parts" <scheme|username|password|host|ipv6_address|port|path|query|fragment...>
# See: https://en.wikipedia.org/wiki/Uniform_Resource_Identifier
# Reviewed: 2019-11-11
function uri_get_parts() {

    local URI="$1" FMT=() EXPR=() PART

    shift

    for PART in "$@"; do

        FMT+=("%s")

        case "$PART" in

        scheme)
            EXPR+=("a[2]")
            ;;

        username)
            EXPR+=("a[5]")
            ;;

        password)
            EXPR+=("a[7]")
            ;;

        host)
            # with brackets if IPv6 address
            EXPR+=("a[8]")
            ;;

        ipv6_address)
            EXPR+=("a[9]")
            ;;

        port)
            EXPR+=("a[11]")
            ;;

        path)
            EXPR+=("a[12]")
            ;;

        query)
            EXPR+=("a[14]")
            ;;

        fragment)
            EXPR+=("a[16]")
            ;;

        *)
            die "Unknown URI component: $PART"
            ;;

        esac

    done

    gnu_awk '{match($0,/^(([a-zA-Z][-a-zA-Z0-9+.]*):)?(\/\/(([-a-zA-Z0-9._~%!$&'"'"'()*+,;=]+)(:([-a-zA-Z0-9._~%!$&'"'"'()*+,;=]*))?@)?([-a-zA-Z0-9._~%!$&'"'"'()*+,;=]+|\[([0-9a-fA-F:]+)\])(:([0-9]+))?)?([-a-zA-Z0-9._~%!$&'"'"'()*+,;=:@/]+)?(\?([-a-zA-Z0-9._~%!$&'"'"'()*+,;=:@?/]+))?(#([-a-zA-Z0-9._~%!$&'"'"'()*+,;=:@?/]*))?$/,a);printf "'"$(array_join_by '\n' "${FMT[@]}")"'\n",'"$(array_join_by ',' "${EXPR[@]}")"'}' <<<"$URI"

}

# files are downloaded to the current directory, and local filenames are output
# Reviewed: 2019-11-30
function download_urls() {

    local URL FILENAME HEADERS DOWNLOAD_FAILED=0 ERROR_MESSAGE HEADER IFS HEADER_PARTS i

    for URL in "$@"; do

        FILENAME=
        HEADERS="$(wget --server-response --timestamping --no-verbose "$URL" 2>&1 >/dev/null)" || DOWNLOAD_FAILED=1

        if [ "$DOWNLOAD_FAILED" -eq "1" ]; then

            ERROR_MESSAGE="Unable to download ($(echo "$HEADERS" | head -n1)): $URL"

            if [ -n "${DOWNLOAD_URLS_SKIP_REGEX:-}" ] && [[ "$(echo "$HEADERS" | head -n1)" =~ $DOWNLOAD_URLS_SKIP_REGEX ]]; then

                echoc "$ERROR_MESSAGE" "$BOLD" "$RED" >&2
                DOWNLOAD_FAILED=0
                continue

            else

                die "$ERROR_MESSAGE"

            fi

        fi

        if HEADER="$(
            . "$SUBSHELL_SCRIPT_PATH" || exit
            echo "$HEADERS" | grep -Ei '^[[:space:]]*Content-Disposition:' | tail -n1 | sed -E 's/(^[[:space:]]*Content-Disposition:)//ig'
        )"; then

            IFS=" ;"
            HEADER_PARTS=($HEADER)
            unset IFS

            for i in "${!HEADER_PARTS[@]}"; do

                HEADER="${HEADER_PARTS[$i]}"

                if FILENAME="$(
                    . "$SUBSHELL_SCRIPT_PATH" || exit
                    echo "$HEADER" | gnu_grep -Pio '(?<=^filename=).*' | sed -E 's/^[[:space:]]*("?)(.*)\1[[:space:]]*$/\2/g'
                )"; then

                    break

                else

                    FILENAME=

                fi

            done

        fi

        if [ -z "$FILENAME" ] || [ ! -e "$FILENAME" ]; then

            FILENAME="$(url_decode "$URL")"
            FILENAME="${FILENAME##*/}"

        fi

        # TODO: use the final "Location:" header to make an additional filename guess
        # (this should mean wget's --content-disposition option can be used safely)
        if [ ! -e "$FILENAME" ]; then

            die "Unable to determine filename for $URL"

        fi

        echo "$PWD/$FILENAME"

        echoc "Finished downloading $URL" "$CYAN" >&2

    done

}

function move_file_delete_link() {

    if [ -L "$1" ]; then

        rm -f "$1"

    elif [ -e "$1" ]; then

        mv -f "$1" "$1.bak"

    fi

}

# get_log_file [suffix]
#   Outputs the path to a writable log file based on the name of the
#   running script and the current user's effective ID.
#
# Reviewed: 2019-12-08
function get_log_file() {

    local LOG_ROOTS LOG_ROOT LOG_BASENAME LOG_PATH

    LOG_ROOTS=(
        "$LOG_DIR"
        ~/.local/var/log
        ~
        /tmp
    )

    LOG_BASENAME="$(basename "$0")${1:-}.$EUID.log"

    for LOG_ROOT in "${LOG_ROOTS[@]}"; do

        [ -d "$LOG_ROOT" ] ||
            { [ ! -e "$LOG_ROOT" ] && mkdir -p "$LOG_ROOT" 2>/dev/null; } ||
            continue

        [ -w "$LOG_ROOT" ] || continue

        LOG_PATH="$LOG_ROOT/$LOG_BASENAME"

        [ -f "$LOG_PATH" ] || [ ! -e "$LOG_PATH" ] || continue

        touch "$LOG_PATH" 2>/dev/null || continue

        echo "$LOG_PATH"
        return

    done

    die "No writable log file location"

}

# start_or_restart [/path/to/]command [arg ...]
#   Kill any running COMMAND processes, then run COMMAND in the
#   background and disown it.
#
# Reviewed: 2019-12-08
function start_or_restart() {

    local COMMAND LOG_FILE LOG_FILE2 LOG_MESSAGE

    COMMAND="$(basename "$1")" || die
    LOG_FILE="$(get_log_file "_$COMMAND.stdout")" || die
    LOG_FILE2="$(get_log_file "_$COMMAND.stderr")" || die

    # limit to processes owned by $USER unless running as root
    is_root || ! pgrep -xu "$USER" "$COMMAND" >/dev/null || echo_run pkill -xu "$USER" "$COMMAND"
    ! is_root || ! pgrep -x "$COMMAND" >/dev/null || echo_run pkill -x "$COMMAND"

    if command_exists "$1"; then

        LOG_MESSAGE="$(date_get_log) [${FUNCNAME[0]}] Running: $*"
        echo $'\n'"$LOG_MESSAGE" >>"$LOG_FILE"
        echo $'\n'"$LOG_MESSAGE" >>"$LOG_FILE2"
        nohup "$@" </dev/null >>"$LOG_FILE" 2>&1 &
        disown

    fi

}

# Reviewed: 2019-11-01
function time_command() {

    local EXIT_CODE=0

    exec 8>&1 9>&2 || die
    COMMAND_TIME="$(
        TIMEFORMAT="${TIMEFORMAT:-%3lR}"
        { time "$@" 1>&8 2>&9; } 2>&1
    )" || EXIT_CODE="$?"
    exec 8>&- 9>&-

    return "$EXIT_CODE"

}

# Usage: maybe_sudo <use sudo? (Y/N)> command [arg1...]
# Reviewed: 2019-10-28
function maybe_sudo() {

    local SUDO_OR_NOT

    SUDO_OR_NOT="$1"
    shift

    if [ "$SUDO_OR_NOT" = "Y" ]; then

        sudo -H "$@"

    else

        "$@"

    fi

}

# Usage: echo_run command [arg1...]
# Reviewed: 2019-11-05
function echo_run() {

    local EXTRA_NEWLINE="\n" ARG ARGS=() EXIT_CODE="0" EXIT_COLOR="${GREEN}"

    [ -t 1 ] || EXTRA_NEWLINE=

    for ARG in "$@"; do

        ARGS+=("$(escape_separators "$ARG")")

    done

    printf "${GREY}[%s] ${BOLD}${CYAN}Running command:${RESET}%s\n${EXTRA_NEWLINE}" "$(date_get_log)" "$(printf ' %s' "${ARGS[@]}")" >&2

    time_command "$@" || {
        EXIT_CODE="$?"
        EXIT_COLOR="${RED}"
    }

    [ "${ECHO_RUN_EXIT_MESSAGE:-N}" = "N" ] && [ "$EXIT_CODE" -eq "0" ] || printf "${EXTRA_NEWLINE}${GREY}[%s] ${BOLD}${EXIT_COLOR}Exit code:${RESET} %s ${GREY}(after %s)${RESET}\n${EXTRA_NEWLINE}" "$(date_get_log)" "$EXIT_CODE" "$COMMAND_TIME" >&2

    return "$EXIT_CODE"

}

# Usage: safe_symlink /path/to/target /path/to/link [use sudo? (y/N)] [add "-default" if target missing? (y/N)]
# Reviewed: 2019-11-20
function safe_symlink() {

    local TARGET="${1:-}" LINK="${2:-}" SUDO_OR_NOT="${3:-N}" TRY_DEFAULT="${4:-N}" CURRENT_TARGET

    [ -n "$TARGET" ] || die "No target"
    [ -n "$LINK" ] || die "No link"

    [ -e "$TARGET" ] || {
        [ "$TRY_DEFAULT" = "Y" ] || return
        TARGET="$(filename_add_suffix "$TARGET" "-default")"
        [ -e "$TARGET" ] || return
    }

    if [ -L "$LINK" ]; then

        CURRENT_TARGET="$(readlink "$LINK")" || die
        [ "$CURRENT_TARGET" != "$TARGET" ] || return 0
        maybe_sudo "$SUDO_OR_NOT" rm -f "$LINK" || die

    elif [ -e "$LINK" ]; then

        maybe_sudo "$SUDO_OR_NOT" mv -fv "$LINK" "$LINK.bak" || die

    else

        maybe_sudo "$SUDO_OR_NOT" mkdir -p "$(dirname "$LINK")" || die

    fi

    maybe_sudo "$SUDO_OR_NOT" ln -sv "$TARGET" "$LINK" || die

}

# Usage: safe_sed /path/to/file sed_command1 [sed_command2...]
# Reviewed: 2019-10-27
function safe_sed() {

    local FILENAME COMMAND COMMANDS=() CHANGED

    FILENAME="$1" || die
    shift

    [ -f "$FILENAME" ] || die "File doesn't exist: $FILENAME"

    for COMMAND in "$@"; do

        COMMANDS+=(-e "$COMMAND")

    done

    CHANGED="$(gnu_sed -E "${COMMANDS[@]}" "$FILENAME")" || die

    if ! diff -q ".git/config" <(printf '%s' "$CHANGED") >/dev/null; then

        printf '%s' "$CHANGED" >"$FILENAME" || die

    fi

}

# Reviewed: 2020-01-18
function is_dryrun() {

    [ "$ORIGINAL_DRYRUN_ARGUMENT" = "--dryrun" ] || { [ "${DRYRUN_BY_DEFAULT:-N}" != "N" ] && [ "$ORIGINAL_DRYRUN_ARGUMENT" != "--run" ]; }

}

# Reviewed: 2020-01-18
function dryrun_message() {

    local EXTRA=

    if is_dryrun; then

        [ "${DRYRUN_BY_DEFAULT:-N}" = "N" ] || EXTRA=" (use \"--run\" as the first argument to override)"

        lc_console_message "$(basename "$0") is in dry run mode${EXTRA}" "$BOLD$RED" >&2

    fi

}

# Usage: maybe_dryrun command [argument1...]
# Reviewed: 2020-01-18
function maybe_dryrun() {

    if is_dryrun; then

        lc_console_item "Command skipped (dry run):" "$*" "$YELLOW" >&2

    else

        "$@"

    fi

}

# Usage: create_temp_file [use $TEMP_DIR? (y/N)]
# Reviewed: 2019-11-21
function create_temp_file() {

    local TEMP_ROOT="/tmp" TEMP_PATH

    [ "${1:-N}" = "N" ] || TEMP_ROOT="$TEMP_DIR"

    TEMP_PATH="$(mktemp "$TEMP_ROOT/$(basename "$0").$(date_get_timestamp).XXXXXXXX")" ||
        die "Unable to create temporary file"

    echo "$TEMP_PATH"

}

# Usage: create_temp_dir [use $TEMP_DIR? (y/N)]
# Reviewed: 2019-11-21
function create_temp_dir() {

    local TEMP_ROOT="/tmp" TEMP_PATH

    [ "${1:-N}" = "N" ] || TEMP_ROOT="$TEMP_DIR"

    TEMP_PATH="$(mktemp -d "$TEMP_ROOT/$(basename "$0").$(date_get_timestamp).XXXXXXXX")" ||
        die "Unable to create temporary directory"

    echo "$TEMP_PATH"

}

# Usage: create_temp_fifo [use $TEMP_DIR? (y/N)]
# Reviewed: 2019-11-21
function create_temp_fifo() {

    local FIFO_DIR FIFO_PATH

    FIFO_PATH="$(create_temp_dir "$@")/fifo"
    mkfifo "$FIFO_PATH" ||
        die "Unable to create temporary FIFO"

    echo "$FIFO_PATH"

}

function flush_fifo() {

    dd if="$1" iflag=nonblock of=/dev/null

}

function get_x_displays() {

    assert_is_desktop

    local X

    if [ -d /tmp/.X11-unix ]; then

        for X in /tmp/.X11-unix/X*; do

            echo ":${X##*X}"

        done

    fi

}

function dir_make_and_own() {

    assert_not_root

    [ -d "$1" ] || sudo mkdir -p "$1" || die

    [ -w "$1" ] || sudo chown "$(id -un):$(id -gn)" "$1" || die

}

function windows_running_as_administrator() {

    assert_command_exists whoami.exe

    whoami.exe /groups | grep '\bS-1-5-32-544\b.*\bEnabled group\b' >/dev/null

}

# because Bash 3.2 exits when eval exits non-zero, regardless of context or errexit status
function eval_test() {

    local EXIT_CODE

    EXIT_CODE="$(eval 'if' "$@" '; then echo "0"; else echo "1"; fi')"

    return "$EXIT_CODE"

}

# Reviewed: 2019-12-02
function link_settings() {

    local i TO

    assert_command_exists realpath

    APP_NAME="${APP_NAME:-app}"

    if [ -n "${COMMAND_CHECK:-}" ]; then

        if ! command_exists "$COMMAND_CHECK"; then

            die "$APP_NAME isn't installed (command doesn't exist: $COMMAND_CHECK)"

        fi

    fi

    if [ -n "${RUNNING_CHECK:-}" ]; then

        if eval_test "$RUNNING_CHECK"; then

            die "$APP_NAME is currently running"

        fi

    fi

    if [ -n "${DIRECTORY_CHECK:-}" ]; then

        if [ ! -d "$DIRECTORY_CHECK" ]; then

            die "$DIRECTORY_CHECK doesn't exist (have you run $APP_NAME yet?)"

        fi

    fi

    if is_windows && ! windows_running_as_administrator; then

        die "$(basename "$0") must be run as administrator for symbolic links to work"

    fi

    console_message "Linking settings files for $APP_NAME" "" "$BOLD" "$CYAN"

    for i in "${!LINK_FROM[@]}"; do

        [ -e "${LINK_TO[$i]}" ] || {
            console_warning "Can't link to missing file ${LINK_TO[$i]}" "" "$BOLD" "$RED"
            continue
        }

        TO="$(realpath "${LINK_TO[$i]}")" || die
        safe_symlink "$TO" "${LINK_FROM[$i]}"

    done

}

# Reviewed: 2019-11-18
function array_filter_platform() {

    printf '%s\n' "$@" | gnu_grep -Po "^[^:]+(?=(:([^:|]+\|)*$PLATFORM(\|[^:|]+)*)?\$)" || true

}

# Usage: install_or_queue "Description of this group" "item1 item2 ..." <allow user override? (y/n)> <singular noun> <plural noun> <name of "installed items" array> <name of "available items" array> <name of "to install" array to fill> [name of "already installed" array to fill]
function install_or_queue() {

    local REQUESTED=($2) UI="$3" SINGLE="$4" PLURAL="$5" ITEMS_INSTALLED ITEMS_AVAILABLE INSTALL_TARGET="$8" ALREADY_INSTALLED_TARGET="${9:-}"

    console_message "Checking ${BOLD}${1}${RESET} $PLURAL" "" "$CYAN"

    local i=6 j k
    for j in ITEMS_INSTALLED ITEMS_AVAILABLE; do

        # k="$6"
        eval 'k="$'"$i"'"'

        if [ -z "$k" ]; then

            eval "$j"'=()'

        elif variable_exists "$k"; then

            # ITEMS_INSTALLED=($(printf '%s\n' "${NAME_OF_ARRAY[@]}" | sort | uniq))
            eval "$j"'=($(printf '"'"'%s\n'"'"' "${'"$k"'[@]}" | sort | uniq))'

        else

            # ITEMS_INSTALLED=($(COMMAND | sort | uniq)) || true
            eval "$j"'=($('"$k"' | sort | uniq)) || true'

        fi

        ((i += 1))

    done

    local IOQ_INSTALL IOQ_UNAVAILABLE IOQ_ALREADY_INSTALLED

    IOQ_INSTALL=($(comm -23 <(printf '%s\n' "${REQUESTED[@]}" | sort | uniq) <([ "${#ITEMS_INSTALLED[@]}" -gt "0" ] && printf '%s\n' "${ITEMS_INSTALLED[@]}" || true)))
    IOQ_ALREADY_INSTALLED=($(comm -12 <(printf '%s\n' "${REQUESTED[@]}" | sort | uniq) <([ "${#ITEMS_INSTALLED[@]}" -gt "0" ] && printf '%s\n' "${ITEMS_INSTALLED[@]}" || true)))

    if [ "${#IOQ_ALREADY_INSTALLED[@]}" -gt "0" ] && [ -n "$ALREADY_INSTALLED_TARGET" ]; then

        eval "$ALREADY_INSTALLED_TARGET"'+=("${IOQ_ALREADY_INSTALLED[@]}")'

    fi

    if [ "${#IOQ_INSTALL[@]}" -gt "0" ]; then

        if [ "${#ITEMS_AVAILABLE[@]}" -gt "0" ]; then

            IOQ_UNAVAILABLE=($(comm -23 <(printf '%s\n' "${IOQ_INSTALL[@]}" | sort | uniq) <(printf '%s\n' "${ITEMS_AVAILABLE[@]}")))

            if [ "${#IOQ_UNAVAILABLE[@]}" -gt "0" ]; then

                console_message "${#IOQ_UNAVAILABLE[@]} $(single_or_plural "${#IOQ_UNAVAILABLE[@]}" "$SINGLE" "$PLURAL") unavailable for installation:" "${IOQ_UNAVAILABLE[*]}" "$BOLD" "$RED"

                IOQ_INSTALL=($(comm -12 <(printf '%s\n' "${IOQ_INSTALL[@]}" | sort | uniq) <(printf '%s\n' "${ITEMS_AVAILABLE[@]}")))

                [ "${#IOQ_INSTALL[@]}" -gt "0" ] || return 0

            fi

        fi

        if [ "$UI" = "Y" ]; then

            console_message "Missing ${#IOQ_INSTALL[@]} $1 $(single_or_plural "${#IOQ_INSTALL[@]}" "$SINGLE" "$PLURAL"):" "${IOQ_INSTALL[*]}" "$BOLD" "$MAGENTA"

            get_confirmation "Add the $1 $(single_or_plural "${#IOQ_INSTALL[@]}" "$SINGLE" "$PLURAL") listed above?" Y Y || return 0

        else

            console_message "Adding ${#IOQ_INSTALL[@]} $1 $(single_or_plural "${#IOQ_INSTALL[@]}" "$SINGLE" "$PLURAL"):" "${IOQ_INSTALL[*]}" "$GREEN"

        fi

        if variable_exists "$INSTALL_TARGET"; then

            eval "$INSTALL_TARGET"'+=("${IOQ_INSTALL[@]}")'

        else

            # shellcheck disable=SC2086
            eval $INSTALL_TARGET "${IOQ_INSTALL[@]}"

        fi

    fi

}

# Usage: test_host_port my.host.address port-number
# Reviewed: 2019-10-28
function test_host_port() {

    # 1-second timeout -- intended for LAN service availability checks
    gnu_nc -zw 1 "$1" "$2" >/dev/null 2>&1

}

# outputs the installed memory size in MiB
function get_memory_size() {

    local MEMSIZE

    if is_linux; then

        assert_command_exists dmidecode

        sudo dmidecode -t memory | sed -E 's/^\s+(.*)$/\1/' | gnu_grep -Po '(?<=^Size: )[0-9]+(?= MB$)' | awk '{ram+=$1} END {print ram}' || die

    elif is_macos; then

        MEMSIZE="$(sysctl -n hw.memsize)" || die
        echo "$((MEMSIZE / 1024 ** 2))"

    else

        die "Unable to determine memory size on this platform"

    fi
}

COMMON_SCRIPT_PATH="$(realpath "${BASH_SOURCE[0]}" 2>/dev/null)" || COMMON_SCRIPT_PATH="$(python -c 'import os,sys;print os.path.realpath(sys.argv[1])' "${BASH_SOURCE[0]}")"
ROOT_DIR_RELATIVE="$(dirname "$COMMON_SCRIPT_PATH")/.."
ROOT_DIR="$(realpath "$ROOT_DIR_RELATIVE" 2>/dev/null)" || ROOT_DIR="$(python -c 'import os,sys;print os.path.realpath(sys.argv[1])' "$ROOT_DIR_RELATIVE")"

. "$ROOT_DIR/bash/common-functions"

CONFIG_DIR="$ROOT_DIR/config"
CACHE_DIR="$ROOT_DIR/cache"
LOCAL_DIR="$ROOT_DIR/local"
LOG_DIR="$ROOT_DIR/log"
TEMP_DIR="$ROOT_DIR/tmp"

SUBSHELL_SCRIPT_PATH="$ROOT_DIR/bash/common-subshell"
SED_IN_PLACE_ARGS=(-i)
FONTPATH=

DELETE_ON_EXIT=()
KILL_ON_EXIT=()

trap 'error_trap "$?" "${BASH_SOURCE[0]}" "$LINENO"' ERR

set -E

trap exit_trap EXIT

shopt -s expand_aliases
alias pop_return1='{ popd >/dev/null; return 1; }'
alias basename='basename --'

ORIGINAL_DRYRUN_ARGUMENT=

if [[ "${1:-}" =~ --(dry)?run ]]; then

    ORIGINAL_DRYRUN_ARGUMENT="$1"
    shift

fi

ORIGINAL_BASH_SUBSHELL="$BASH_SUBSHELL"
ORIGINAL_ARGUMENTS=("$@")

register_gnu_commands awk date grep nc sed sort stat tar

mkdir -p "$CONFIG_DIR" "$CACHE_DIR" "$LOCAL_DIR" "$LOG_DIR" "$TEMP_DIR"

if [ -t 1 ]; then

    # foreground colours
    BLACK="$(tput setaf 0)"
    RED="$(tput setaf 1)"
    GREEN="$(tput setaf 2)"
    YELLOW="$(tput setaf 3)"
    BLUE="$(tput setaf 4)"
    MAGENTA="$(tput setaf 5)"
    CYAN="$(tput setaf 6)"
    WHITE="$(tput setaf 7)"
    GREY="$(tput setaf 8)"

    # background colours
    BLACK_BG="$(tput setab 0)"
    RED_BG="$(tput setab 1)"
    GREEN_BG="$(tput setab 2)"
    YELLOW_BG="$(tput setab 3)"
    BLUE_BG="$(tput setab 4)"
    MAGENTA_BG="$(tput setab 5)"
    CYAN_BG="$(tput setab 6)"
    WHITE_BG="$(tput setab 7)"
    GREY_BG="$(tput setab 8)"

    # other "formatting"
    BOLD="$(tput bold)"
    UNDERLINE="$(tput smul)"
    NO_UNDERLINE="$(tput rmul)"
    STANDOUT="$(tput smso)"
    NO_STANDOUT="$(tput rmso)"
    NO_WRAP="$(tput rmam)"
    WRAP="$(tput smam)"
    RESET="$(tput sgr0)"

else

    BLACK=
    RED=
    GREEN=
    YELLOW=
    BLUE=
    MAGENTA=
    CYAN=
    WHITE=
    GREY=
    BLACK_BG=
    RED_BG=
    GREEN_BG=
    YELLOW_BG=
    BLUE_BG=
    MAGENTA_BG=
    CYAN_BG=
    WHITE_BG=
    GREY_BG=
    BOLD=
    UNDERLINE=
    NO_UNDERLINE=
    STANDOUT=
    NO_STANDOUT=
    NO_WRAP=
    WRAP=
    RESET=

fi

IS_MACOS=0
IS_LINUX=0
IS_UBUNTU=0
IS_WSL=0
HAS_GUI=0
PLATFORM=

case "$(uname -s)" in

Darwin)

    IS_MACOS=1
    PLATFORM=mac
    HAS_GUI=1
    SED_IN_PLACE_ARGS+=("")
    FONTPATH="${HOME:+$HOME/Library/Fonts:}/Library/Fonts"
    . "$ROOT_DIR/bash/common-macos"
    ;;

Linux)

    IS_LINUX=1

    if [ -e /proc/version ] && grep -q Microsoft /proc/version; then

        IS_WSL=1
        PLATFORM=wsl
        FONTPATH="/mnt/c/Windows/Fonts"

    else

        PLATFORM=linux
        command_exists X && HAS_GUI=1
        FONTPATH="${HOME:+$HOME/.local/share/fonts:}/usr/share/fonts"

    fi

    if command_exists lsb_release; then

        if [ -e "$CACHE_DIR/.lsb-release" ]; then

            # shellcheck disable=SC1090
            . "$CACHE_DIR/.lsb-release"

        else

            DISTRIB_ID="$(lsb_release -si)"
            DISTRIB_RELEASE="$(lsb_release -sr)"
            DISTRIB_CODENAME="$(lsb_release -sc)"
            DISTRIB_DESCRIPTION="$(lsb_release -sd)"

            cat <<EOF >"$CACHE_DIR/.lsb-release"
DISTRIB_ID="$DISTRIB_ID"
DISTRIB_RELEASE="$DISTRIB_RELEASE"
DISTRIB_CODENAME="$DISTRIB_CODENAME"
DISTRIB_DESCRIPTION="$DISTRIB_DESCRIPTION"
EOF

        fi

        if [ "$DISTRIB_ID" = "Ubuntu" ]; then

            IS_UBUNTU=1

        fi

    fi

    . "$ROOT_DIR/bash/common-linux"

    ;;

*)

    die "Error: unknown platform"
    ;;

esac

[ -e "$CONFIG_DIR/settings-default" ] && . "$CONFIG_DIR/settings-default" || true
[ -e "$CONFIG_DIR/settings" ] && . "$CONFIG_DIR/settings" || true
