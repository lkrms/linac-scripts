#!/bin/bash
# shellcheck disable=SC2016,SC2034,SC2068

# common-functions
#   Provide various portable, self-contained Bash functions.

# TBA:
# - function die()
# - function search_replace()
# - function single_or_plural()
# - function filename_add_suffix()
# - $CYAN etc.

function lc_is_yes() {
    [[ "$1" =~ ^[yY]$ ]]
}

function lc_is_true() {
    [[ "$1" =~ ^([yY1])$ ]]
}

function lc_echo_array() {
    printf '%s\n' "$@"
}

# lc_echoc [-neE] message [colour_sequence ...]
function lc_echoc() {

    local ECHO_ARGS=() MESSAGE IFS COLOURS=

    while [[ "${1:-}" =~ ^-[neE]+$ ]]; do

        ECHO_ARGS+=("$1")
        shift

    done

    MESSAGE="${1:-}"
    shift || true

    if [ "$#" -gt "0" ] && [ -n "$RESET" ]; then

        IFS=
        COLOURS="$*"
        unset IFS

        MESSAGE="$(search_replace "$RESET" "$RESET$COLOURS" "$MESSAGE")"

    fi

    echo ${ECHO_ARGS[@]+"${ECHO_ARGS[@]}"} "$COLOURS$MESSAGE$RESET"

}

# lc_console_message message [[secondary_message] colour_sequence]
function lc_console_message() {

    local MESSAGE COLOURS MESSAGE2=

    MESSAGE="$1" || die
    shift
    [ "$#" -le "1" ] || {
        MESSAGE2="$1"
        shift
    }
    COLOURS="${1:-${!LC_DEFAULT_CONSOLE_COLOUR}}"

    # - atomic unless larger than buffer (smaller of PIPE_BUF, BUFSIZ)
    # - there's no portable way to determine buffer size
    # - writing <=512 bytes with echo or printf should be atomic on all
    #   platforms, but this can't be guaranteed
    echo "$(
        lc_echoc -n "==> " "$COLOURS"
        lc_echoc -n "$MESSAGE" "$BOLD"
        [ -z "$MESSAGE2" ] || lc_echoc -n " $MESSAGE2" "$COLOURS"
    )"

}

# lc_console_item message item [colour_sequence]
function lc_console_item() {
    lc_console_message "${1%:}:" "$2" "${3:-}"
}

# lc_console_list message [single_noun plural_noun] [colour_sequence]
function lc_console_list() {

    local MESSAGE SINGLE_NOUN PLURAL_NOUN COLOURS ITEM ITEMS=()

    MESSAGE="$1" || die
    shift
    [ "$#" -le "1" ] || {
        SINGLE_NOUN="$1"
        PLURAL_NOUN="$2"
        shift 2
    }
    COLOURS="${1:-${!LC_DEFAULT_CONSOLE_COLOUR}}"

    while IFS= read -rd "${DELIM:-$'\n'}" ITEM || [ -n "$ITEM" ]; do

        [ -z "$ITEM" ] || ITEMS+=("${ITEM//$'\n'/ }")

    done

    lc_console_message "${MESSAGE%:}:" "$COLOURS"
    [ "${#ITEMS[@]}" -eq "0" ] || lc_echoc "$(printf '%s\n' "${ITEMS[@]}" | column)" "$COLOURS"
    [ -z "${SINGLE_NOUN:-}" ] || echo "(${#ITEMS[@]} $(single_or_plural "${#ITEMS[@]}" "$SINGLE_NOUN" "$PLURAL_NOUN"))"

}

# SUDO_OR_NOT=<Y|N> lc_maybe_sudo command [arg1...]
function lc_maybe_sudo() {
    if lc_is_yes "${SUDO_OR_NOT:-N}"; then
        sudo -H "$@"
    else
        "$@"
    fi
}

# lc_safe_symlink target_path link_path [use_sudo [try_default]]
function lc_safe_symlink() {

    local TARGET="${1:-}" LINK="${2:-}" SUDO_OR_NOT="${3:-N}" TRY_DEFAULT="${4:-N}" CURRENT_TARGET

    LC_SAFE_SYMLINK_NO_CHANGE=

    [ -n "$TARGET" ] || die "No target"
    [ -n "$LINK" ] || die "No link"

    [ -e "$TARGET" ] || {
        lc_is_yes "$TRY_DEFAULT" || return
        TARGET="$(filename_add_suffix "$TARGET" "-default")"
        [ -e "$TARGET" ] || return
    }

    if [ -L "$LINK" ]; then
        CURRENT_TARGET="$(readlink "$LINK")" || die
        [ "$CURRENT_TARGET" != "$TARGET" ] || {
            LC_SAFE_SYMLINK_NO_CHANGE=1
            return
        }
        lc_maybe_sudo rm -f "$LINK" || return
    elif [ -e "$LINK" ]; then
        lc_maybe_sudo mv -fv "$LINK" "$LINK.bak" || return
    else
        lc_maybe_sudo mkdir -p "$(dirname "$LINK")" || return
    fi

    lc_maybe_sudo ln -sv "$TARGET" "$LINK"

}

function lc_register_gnu_commands() {
    local COMMAND PREFIX=

    ! lc_is_macos || PREFIX="g"
    for COMMAND in "$@"; do
        eval "function gnu_$COMMAND() { $PREFIX$COMMAND \"\$@\"; }"
    done
}

function lc_sort_files_by_date() {

    gnu_stat --printf '%Y :%n\0' "$@" | sort -zn | gnu_sed -zE 's/[0-9]+ ://' | xargs -0 printf '%s\n'

}

function lc_sort_files_by_date_reverse() {

    gnu_stat --printf '%Y :%n\0' "$@" | sort -znr | gnu_sed -zE 's/[0-9]+ ://' | xargs -0 printf '%s\n'

}

function lc_largest() {

    gnu_find . -xdev -type f ${@+\( "$@" \)} -print0 | xargs -0 gnu_stat --format '%14s %N' | sort -nr | less

}

function lc_is_identifier() {
    [[ "$1" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]
}

function lc_variable_set() {
    # the second test works with empty arrays
    eval "[ -n \"\${$1+s}\" ]" ||
        declare -p "$1" >/dev/null 2>&1
}

function lc_return_cached() {
    lc_variable_set "$1" || {
        eval "$2;$1=\"\$?\""
    }
    eval "return \"\$$1\""
}

function lc_is_macos() {
    lc_return_cached LC_IS_MACOS '[ "$(uname -s)" = "Darwin" ]'
}

LC_DEFAULT_CONSOLE_COLOUR="CYAN"

lc_register_gnu_commands find sed stat
