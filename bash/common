#!/bin/bash
# shellcheck disable=SC2034

set -euo pipefail

function error_trap() {

    echo "Error: $(basename "$0") failed with exit code $1 in $2 at line $3" >&2
    exit "$1"

}

trap 'error_trap "$?" "${BASH_SOURCE[0]}" "$LINENO"' ERR

set -E

SCRIPT_ARGS=("$@")

function assert_is_macos() {

    if [ "$IS_MACOS" -ne "1" ]; then

        die "Error: $(basename "$0") is not supported on this platform (macOS required)"

    fi

}

function assert_is_linux() {

    if [ "$IS_LINUX" -ne "1" ]; then

        die "Error: $(basename "$0") is not supported on this platform (Linux required)"

    fi

}

function assert_is_ubuntu() {

    if [ "$IS_UBUNTU" -ne "1" ]; then

        die "Error: $(basename "$0") is not supported on this platform (Ubuntu required)"

    fi

}

function assert_not_server() {

    if [ "$IS_SERVER" -eq "1" ]; then

        die "Error: $(basename "$0") requires a desktop environment"

    fi

}

function assert_is_ubuntu_lts() {

    assert_is_ubuntu
    assert_command_exists ubuntu-distro-info

    if ! ubuntu-distro-info --supported-esm | grep "^${DISTRIB_CODENAME}\$" >/dev/null 2>&1; then

        die "Error: $(basename "$0") is only supported on LTS releases of Ubuntu"

    fi

}

function assert_root() {

    if [ "$EUID" -ne "0" ]; then

        die "Error: $(basename "$0") must be run as the superuser"

    fi

}

function assert_not_root() {

    if [ "$EUID" -eq "0" ]; then

        die "Error: $(basename "$0") can't be run as the superuser"

    fi

}

function assert_command_exists() {

    if ! command_exists "$1"; then

        die "Error: $(basename "$0") requires $1"

    fi

}

function assert_function_exists() {

    if ! function_exists "$1"; then

        die "Error: $(basename "$0") requires Bash function $1"

    fi

}

function command_exists() {

    command -v "$1" >/dev/null 2>&1

}

function function_exists() {

    declare -F "$1" >/dev/null 2>&1

}

function is_bool() {

    [[ "$1" =~ ^(true|false)$ ]]

}

function is_int() {

    [[ "$1" =~ ^[0-9]+$ ]]

}

# Usage: echoc "My coloured message" "$BOLD" "$BLUE"
function echoc() {

    echocn "$@"
    echo

}

# as above, but no newline afterwards
function echocn() {

    local MESSAGE="$1" c

    shift

    for c in "$@"; do

        echo -ne "$c"

    done

    echo -ne "${MESSAGE}${RESET}"

}

function die() {

    [ "$#" -gt "0" ] && echoc "$@" >&2 || true

    exit 1

}

# Usage: console_message "Main message" "Secondary message with colour too" "$BOLD" "$BLUE"
function console_message() {

    local MESSAGE1="$1" MESSAGE2="$2"

    shift
    shift
    echocn "==> " "$@"
    echocn "$MESSAGE1"
    [ -n "$MESSAGE2" ] && echocn " $MESSAGE2" "$@" || true
    echo

}

# Usage: get_confirmation "Do this?" [default response (y/n)] [force valid response? (y/N)] && { do_it; }
function get_confirmation() {

    local PROMPT=() DEFAULT="${2:-}" FORCE="${3:-N}" YN

    [ -n "$1" ] && PROMPT+=("$1") || true

    case "$DEFAULT" in

    Y)
        PROMPT+=("[Y/n]")
        ;;

    N)
        PROMPT+=("[y/N]")
        ;;

    *)
        PROMPT+=("[y/n]")
        ;;

    esac

    while :; do

        read -rp "${PROMPT[*]} " YN

        [ -z "$YN" ] && [ -n "$DEFAULT" ] && YN="$DEFAULT" || true

        YN="$(upper "$YN")"

        if [ "$FORCE" != "Y" ] || [[ "$YN" =~ ^(Y|YES|N|NO)$ ]]; then

            break

        fi

    done

    [[ "$YN" =~ ^(Y|YES)$ ]]

}

# Usage: file_to_array "/path/to/file" [exclude-pattern...]
function file_to_array() {

    local FILENAME LINE PATTERN

    FILENAME="$1"
    shift

    FILE_TO_ARRAY=()

    while IFS= read -r LINE || [ -n "$LINE" ]; do

        for PATTERN in "$@"; do

            [[ "$LINE" =~ $PATTERN ]] && continue 2 || true

        done

        FILE_TO_ARRAY+=("$LINE")

    done <"$FILENAME"

}

# Usage: single_or_plural <number> "singular noun" "plural noun"
function single_or_plural() {

    if [ "$1" -eq "1" ]; then

        echo "$2"

    else

        echo "$3"

    fi

}

function upper_first() {

    echo "$(echo "$1" | cut -c1 | tr "[:lower:]" "[:upper:]")$(echo "$1" | cut -c2-)"

}

function lower() {

    echo "$1" | tr "[:upper:]" "[:lower:]"

}

function upper() {

    echo "$1" | tr "[:lower:]" "[:upper:]"

}

# Searches the array (must be global, passed by name) for the given value and outputs the first corresponding key if successful.
# Plays nicely with globs and sparse arrays. Outputs nothing and exits non-zero if the value isn't found.
#
# Usage: array_search <needle> <haystack-name>
function array_search() {

    local KEYS VALUE i

    eval KEYS='"${!'"$2"'[@]}"'

    for i in $KEYS; do

        eval VALUE='"${'"$2"'[$i]}"'

        # $VALUE is left unquoted for globbing purposes
        # shellcheck disable=SC2053
        if [[ "$1" == $VALUE ]] || [[ "$VALUE" == $1 ]]; then

            echo "$i"
            return

        fi

    done

    return 1

}

# Usage: array_join_by ":" "${MY_ARRAY[@]}"
function array_join_by() {

    local IFS="$1"

    shift
    echo "$*"

}

function offer_sudo_password_bypass() {

    # don't proceed if there's no point
    groups | grep -Eq '\b(admin|sudo)\b' || return 0

    local USERNAME="${SUDO_USER:-$USER}" FILENAME CHECK_FILENAME

    FILENAME="/etc/sudoers.d/nopasswd-$USERNAME"
    CHECK_FILENAME="$CACHE_DIR/.nopasswd-$USERNAME"

    if [ -e "$CHECK_FILENAME" ]; then

        return

    fi

    console_message "Please provide your computer password if requested" "" "$BLUE"

    # check that we can, in fact, sudo as root
    if ! sudo true; then

        return 0

    fi

    if ! sudo test -e "$FILENAME"; then

        if get_confirmation "Allow user ${BOLD}${USERNAME}${RESET} to skip future password prompts?" Y Y; then

            sudo tee "$FILENAME" >/dev/null <<EOF && sudo chmod 0440 "$FILENAME" || die
${USERNAME} ALL=(ALL) NOPASSWD:ALL
EOF

        else

            return 0

        fi

    fi

    # attempt to save time next time
    { touch "$CHECK_FILENAME" || sudo touch "$CHECK_FILENAME"; } >/dev/null 2>&1 || true

}

# Usage: sed_escape_search "text to escape" [extended regular expressions? (Y/n)]
function sed_escape_search() {

    if [ "${2:-Y}" = "Y" ]; then

        # shellcheck disable=SC2016
        echo "${1:-}" | sed 's/[]$()*+./?\^{|}[]/\\&/g'

    else

        echo "${1:-}" | sed 's/[]$*./\^[]/\\&/g'

    fi

}

function sed_escape_replace() {

    local ESCAPED

    ESCAPED="$(echo "${1:-}" | sed 's/[\/&]/\\&/g')"
    echo "${ESCAPED//$'\n'/\\n}"

}

function get_yyyymmddhhmmss() {

    date +'%Y%m%d%H%M%S'

}

function url_decode() {

    echo -e "${*//%/\\x}"

}

# results are returned in document order without de-duplication
function get_urls_from_url() {

    # from: https://daringfireball.net/2009/11/liberal_regex_for_matching_urls
    wget -qO - "$1" | grep -Po '\b(([\w-]+://?|www[.])[^\s()<>]+(?:\([\w\d]+\)|([^[:punct:]\s]|/)))'

}

# files are downloaded to the current directory, and local filenames are output
function download_urls() {

    local DOWNLOAD_FAILED=0 URL PRETTY_URL HEADERS HEADER HEADER_PARTS IFS FILENAME

    for URL in "$@"; do

        FILENAME=
        PRETTY_URL="${NO_WRAP}${URL}${WRAP}"
        HEADERS="$(wget -SNnv "$URL" 2>&1 >/dev/null)" || DOWNLOAD_FAILED=1

        if [ "$DOWNLOAD_FAILED" -eq "1" ]; then

            console_message "Unable to download ($(echo "$HEADERS" | head -n1)):" "$PRETTY_URL" "$BOLD" "$RED" >&2
            die

        fi

        if HEADER="$(
            set -euo pipefail
            echo "$HEADERS" | grep -Ei '^[[:space:]]*Content-Disposition:' | tail -n1 | sed -E 's/(^[[:space:]]*Content-Disposition:)//ig'
        )"; then

            IFS=" ;"
            HEADER_PARTS=($HEADER)
            unset IFS

            for HEADER in "${HEADER_PARTS[@]}"; do

                if FILENAME="$(
                    set -euo pipefail
                    echo "$HEADER" | grep -Pio '(?<=^filename=).*' | sed -E 's/^[[:space:]]*("?)(.*)\1[[:space:]]*$/\2/g'
                )"; then

                    break

                else

                    FILENAME=

                fi

            done

        fi

        if [ -z "$FILENAME" ] || [ ! -e "$FILENAME" ]; then

            FILENAME="$(url_decode "$URL")"
            FILENAME="${FILENAME##*\/}"

        fi

        if [ ! -e "$FILENAME" ]; then

            console_message "Unable to determine filename for:" "$PRETTY_URL" "$BOLD" "$RED" >&2
            die

        fi

        echo "$(pwd)/$FILENAME"

        console_message "Finished downloading:" "$PRETTY_URL" "$CYAN" >&2

    done

}

function move_file_delete_link() {

    if [ -e "$1" ]; then

        if [ -L "$1" ]; then

            rm -f "$1"

        else

            mv -f "$1" "$1.bak"

        fi

    fi

}

COMMON_SCRIPT_PATH="${BASH_SOURCE[0]}"
if command -v realpath >/dev/null 2>&1; then COMMON_SCRIPT_PATH="$(realpath "$COMMON_SCRIPT_PATH")"; fi
ROOT_DIR="$(cd "$(dirname "$COMMON_SCRIPT_PATH")/.." && pwd -P)"
CONFIG_DIR="$ROOT_DIR/config"
CACHE_DIR="$ROOT_DIR/cache"
LOG_DIR="$ROOT_DIR/log"
TEMP_DIR="$ROOT_DIR/tmp"

mkdir -p "$CONFIG_DIR" "$CACHE_DIR" "$LOG_DIR" "$TEMP_DIR"

if [ -t 1 ]; then

    # foreground colours
    BLACK="$(tput setaf 0)"
    RED="$(tput setaf 1)"
    GREEN="$(tput setaf 2)"
    YELLOW="$(tput setaf 3)"
    BLUE="$(tput setaf 4)"
    MAGENTA="$(tput setaf 5)"
    CYAN="$(tput setaf 6)"
    WHITE="$(tput setaf 7)"

    # background colours
    BLACK_BG="$(tput setab 0)"
    RED_BG="$(tput setab 1)"
    GREEN_BG="$(tput setab 2)"
    YELLOW_BG="$(tput setab 3)"
    BLUE_BG="$(tput setab 4)"
    MAGENTA_BG="$(tput setab 5)"
    CYAN_BG="$(tput setab 6)"
    WHITE_BG="$(tput setab 7)"

    # other "formatting"
    BOLD="$(tput bold)"
    UNDERLINE="$(tput smul)"
    NO_UNDERLINE="$(tput rmul)"
    STANDOUT="$(tput smso)"
    NO_STANDOUT="$(tput rmso)"
    NO_WRAP="$(tput rmam)"
    WRAP="$(tput smam)"
    RESET="$(tput sgr0)"

else

    BLACK=
    RED=
    GREEN=
    YELLOW=
    BLUE=
    MAGENTA=
    CYAN=
    WHITE=
    BLACK_BG=
    RED_BG=
    GREEN_BG=
    YELLOW_BG=
    BLUE_BG=
    MAGENTA_BG=
    CYAN_BG=
    WHITE_BG=
    BOLD=
    UNDERLINE=
    NO_UNDERLINE=
    STANDOUT=
    NO_STANDOUT=
    NO_WRAP=
    WRAP=
    RESET=

fi

IS_MACOS=0
IS_LINUX=0
IS_UBUNTU=0
IS_SERVER=0
IS_ELEMENTARY_OS=0
IS_PURE_LINUX=0
IS_WSL=0
PLATFORM=

case "$(uname -s)" in

Darwin)

    IS_MACOS=1
    PLATFORM=mac

    ;;

Linux)

    IS_LINUX=1

    if [ -e /proc/version ] && grep -q Microsoft /proc/version; then

        IS_WSL=1
        PLATFORM=wsl

    else

        IS_PURE_LINUX=1
        PLATFORM=linux

    fi

    command_exists X || IS_SERVER=1

    if command_exists lsb_release; then

        if [ -e "$CACHE_DIR/.lsb-release" ]; then

            # shellcheck disable=SC1090
            . "$CACHE_DIR/.lsb-release"

        else

            DISTRIB_ID="$(lsb_release -si)"
            LSB_RELEASE_EXTRA=

            if [[ "$DISTRIB_ID" == elementary* ]]; then

                DISTRIB_ID="$(lsb_release -siu)"
                LSB_RELEASE_EXTRA=u
                IS_ELEMENTARY_OS=1

            fi

            DISTRIB_RELEASE="$(lsb_release -sr$LSB_RELEASE_EXTRA)"
            DISTRIB_CODENAME="$(lsb_release -sc$LSB_RELEASE_EXTRA)"
            DISTRIB_DESCRIPTION="$(lsb_release -sd$LSB_RELEASE_EXTRA)"

            cat <<EOF >"$CACHE_DIR/.lsb-release"
DISTRIB_ID="$DISTRIB_ID"
DISTRIB_RELEASE="$DISTRIB_RELEASE"
DISTRIB_CODENAME="$DISTRIB_CODENAME"
DISTRIB_DESCRIPTION="$DISTRIB_DESCRIPTION"
IS_ELEMENTARY_OS=$IS_ELEMENTARY_OS
EOF

        fi

        if [ "$DISTRIB_ID" = "Ubuntu" ]; then

            IS_UBUNTU=1

        fi

    fi

    ;;

*)

    die "Error: unknown platform"

    ;;

esac

SED_IN_PLACE_ARGS=(-i)

if [ "$IS_MACOS" -eq 1 ]; then

    SED_IN_PLACE_ARGS+=("")

fi
