set -euo pipefail

function error_trap() {

    echo "Error: $(basename "$0") failed with exit code $1 in $2 at line $3" >&2
    exit $1

}

trap 'error_trap "$?" "${BASH_SOURCE[0]}" "$LINENO"' ERR

set -E

SCRIPT_ARGS=("$@")

function assert_is_macos() {

    if [ "$IS_MACOS" -ne "1" ]; then

        die "Error: $(basename "$0") is not supported on this platform (macOS required)"

    fi

}

function assert_is_linux() {

    if [ "$IS_LINUX" -ne "1" ]; then

        die "Error: $(basename "$0") is not supported on this platform (Linux required)"

    fi

}

function assert_is_ubuntu() {

    if [ "$IS_UBUNTU" -ne "1" ]; then

        die "Error: $(basename "$0") is not supported on this platform (Ubuntu required)"

    fi

}

function assert_not_server() {

    if [ "$IS_SERVER" -eq "1" ]; then

        die "Error: $(basename "$0") requires a desktop environment"

    fi

}

function assert_apt_available() {

    assert_is_linux

    if [ "$IS_APT_INSTALLED" -ne "1" ]; then

        die "Error: $(basename "$0") requires apt and dpkg"

    fi

}

function assert_is_ubuntu_lts() {

    assert_is_ubuntu
    assert_function_exists "apt_require_package"

    command_exists ubuntu-distro-info || apt_require_package "distro-info"

    if ! ubuntu-distro-info --supported-esm | grep "^${DISTRIB_CODENAME}\$" >/dev/null 2>&1; then

        die "Error: $(basename "$0") is only supported on LTS releases of Ubuntu"

    fi

}

function assert_root() {

    if [ "$EUID" -ne "0" ]; then

        die "Error: $(basename "$0") must be run as the superuser"

    fi

}

function assert_not_root() {

    if [ "$EUID" -eq "0" ]; then

        die "Error: $(basename "$0") can't be run as the superuser"

    fi

}

function assert_command_exists() {

    if ! command_exists "$1"; then

        die "Error: $(basename "$0") requires $1"

    fi

}

function assert_function_exists() {

    if ! function_exists "$1"; then

        die "Error: $(basename "$0") requires Bash function $1"

    fi

}

function command_exists() {

    command -v "$1" >/dev/null 2>&1

}

function function_exists() {

    declare -F "$1" >/dev/null 2>&1

}

function is_bool() {

    [[ "$1" =~ ^(true|false)$ ]]

}

function is_int() {

    [[ "$1" =~ ^[0-9]+$ ]]

}

# Usage: echoc "My coloured message" $BOLD $BLUE
function echoc() {

    echocn "$@"
    echo

}

# as above, but no newline afterwards
function echocn() {

    local MESSAGE="$1" c

    shift

    for c in "$@"; do

        echo -ne "$c"

    done

    echo -ne "${MESSAGE}${RESET}"

}

function die() {

    [ "$#" -gt "0" ] && echoc "$@" >&2 || true

    exit 1

}

# Usage: console_message "Main message" "Secondary message with colour too" $BOLD $BLUE
function console_message() {

    local MESSAGE1="$1" MESSAGE2="$2"

    shift
    shift
    echocn "==> " "$@"
    echocn "$MESSAGE1"
    [ -n "$MESSAGE2" ] && echocn " $MESSAGE2" "$@" || true
    echo

}

# Usage: get_confirmation "Do this?" [default response (y/n)] [force valid response? (y/N)] && { do_it; }
function get_confirmation() {

    local PROMPT=() DEFAULT="${2:-}" FORCE="${3:-N}" YN

    [ -n "$1" ] && PROMPT+=("$1") || true

    case "$DEFAULT" in

    Y)
        PROMPT+=("[Y/n]")
        ;;

    N)
        PROMPT+=("[y/N]")
        ;;

    *)
        PROMPT+=("[y/n]")
        ;;

    esac

    while :; do

        read -p "${PROMPT[*]} " YN

        [ -z "$YN" -a -n "$DEFAULT" ] && YN="$DEFAULT" || true

        YN="$(upper "$YN")"

        if [ "$FORCE" != "Y" ] || [[ "$YN" =~ ^(Y|YES|N|NO)$ ]]; then

            break

        fi

    done

    [[ "$YN" =~ ^(Y|YES)$ ]]

}

# Usage: file_to_array "/path/to/file" [exclude-pattern...]
function file_to_array() {

    local FILENAME LINE PATTERN

    FILENAME="$1"
    shift

    FILE_TO_ARRAY=()

    while IFS= read -r LINE || [ -n "$LINE" ]; do

        for PATTERN in "$@"; do

            [[ "$LINE" =~ $PATTERN ]] && continue 2 || true

        done

        FILE_TO_ARRAY+=("$LINE")

    done <"$FILENAME"

}

# Usage: single_or_plural <number> "singular noun" "plural noun"
function single_or_plural() {

    if [ "$1" -eq "1" ]; then

        echo "$2"

    else

        echo "$3"

    fi

}

function upper_first() {

    echo "$(echo "$1" | cut -c1 | tr "[:lower:]" "[:upper:]")$(echo "$1" | cut -c2-)"

}

function lower() {

    echo "$(echo "$1" | tr "[:upper:]" "[:lower:]")"

}

function upper() {

    echo "$(echo "$1" | tr "[:lower:]" "[:upper:]")"

}

# Searches the array (must be global, passed by name) for the given value and outputs the first corresponding key if successful.
# Plays nicely with globs and sparse arrays. Returns an empty string if the value isn't found.
#
# Usage: array_search <needle> <haystack-name>
function array_search() {

    local KEYS VALUE

    eval KEYS='"${!'"$2"'[@]}"'

    for i in $KEYS; do

        eval VALUE='"${'"$2"'[$i]}"'

        # $VALUE is left unquoted for globbing purposes
        if [[ "$1" == $VALUE ]]; then

            echo "$i"
            return

        fi

    done

    return 1

}

# Usage: array_join_by ":" "${MY_ARRAY[@]}"
function array_join_by() {

    local IFS="$1"

    shift
    echo "$*"

}

function offer_sudo_password_bypass() {

    local USERNAME="${SUDO_USER:-$USER}" FILENAME CHECK_FILENAME

    FILENAME="/etc/sudoers.d/nopasswd-$USERNAME"
    CHECK_FILENAME="$RS_CONFIG_DIR/.nopasswd-$USERNAME"

    [ -e "$CHECK_FILENAME" ] && return || true

    console_message "Please provide your computer password if requested" "" $BLUE

    if ! sudo test -e "$FILENAME"; then

        if get_confirmation "Allow user ${BOLD}${USERNAME}${RESET} to skip future password prompts?"; then

            sudo tee "$FILENAME" >/dev/null <<EOF && sudo chmod 0440 "$FILENAME" || die
${USERNAME} ALL=(ALL) NOPASSWD:ALL
EOF

        else

            return

        fi

    fi

    # save time next time
    touch "$CHECK_FILENAME" || die

}

# Usage: sed_escape_search "text to escape" [extended regular expressions? (Y/n)]
function sed_escape_search() {

    if [ "${2:-Y}" = "Y" ]; then

        echo "${1:-}" | sed 's/[]$()*+./?\^{|}[]/\\&/g'

    else

        echo "${1:-}" | sed 's/[]$*./\^[]/\\&/g'

    fi

}

function sed_escape_replace() {

    local ESCAPED=$(echo "${1:-}" | sed 's/[\/&]/\\&/g')
    echo "${ESCAPED//$'\n'/\\n}"

}

function git_add_global_ignore() {

    local i IGNORE_FILE

    IGNORE_FILE="$(git config --global core.excludesFile)" || die "Error: Git global option core.excludesFile not defined"
    IGNORE_FILE="${IGNORE_FILE/#\~/$HOME}"

    [ -f "$IGNORE_FILE" ] || touch "$IGNORE_FILE" || die

    [ -f "$IGNORE_FILE" ] || die "Error: unable to create file $IGNORE_FILE"

    for i in "$@"; do

        if ! grep -q '^'"$(sed_escape_search "$i" N)"'$' "$IGNORE_FILE"; then

            echo "$i" >>"$IGNORE_FILE"

        fi

    done

}

# Usage: git_add_global_setting <setting.name> <value> [change if already set? (y/N)]
function git_add_global_setting() {

    if [ "${3:-N}" = "Y" ] || ! git config --global "$1" >/dev/null 2>&1; then

        local EXTRA=()

        if is_bool "$1"; then

            EXTRA+=("--bool")

        elif is_int "$1"; then

            EXTRA+=("--int")

        fi

        git config --global "${EXTRA[@]}" "$1" "$2"

    fi

}

function apply_system_config() {

    if command_exists git; then

        if [ -e "$RS_CONFIG_DIR/gitignore" ]; then

            git_add_global_setting core.excludesFile "~/.gitignore"
            file_to_array "$RS_CONFIG_DIR/gitignore" '^[[:space:]]*$' '^#'
            git_add_global_ignore "${FILE_TO_ARRAY[@]}"

        fi

        git_add_global_setting push.default simple

        local MERGETOOL=

        command_exists meld && MERGETOOL=meld || true

        if [ -n "$MERGETOOL" ]; then

            git_add_global_setting merge.guitool "$MERGETOOL" Y
            git_add_global_setting mergetool.prompt false

        fi

    fi

    if command_exists php && ! command_exists composer && [ ! -e /usr/local/bin/composer -a -d /usr/local ]; then

        {
            sudo mkdir -p /usr/local/bin &&
                "$RS_ROOT_DIR/bash/composer-install.sh" &&
                sudo mv "composer.phar" /usr/local/bin/composer
        } || console_message "Unable to install Composer" "" $BOLD $RED >&2

    fi

    if command_exists composer; then

        composer global require "friendsofphp/php-cs-fixer"

    fi

}

# results are returned in document order without de-duplication
function get_urls_from_url() {

    # from: https://daringfireball.net/2009/11/liberal_regex_for_matching_urls
    wget -qO - "$1" | grep -Po '\b(([\w-]+://?|www[.])[^\s()<>]+(?:\([\w\d]+\)|([^[:punct:]\s]|/)))'

}

RS_SCRIPT_PATH="${BASH_SOURCE[0]}"
if command -v realpath >/dev/null 2>&1; then RS_SCRIPT_PATH="$(realpath "$RS_SCRIPT_PATH")"; fi
RS_ROOT_DIR="$(cd "$(dirname "$RS_SCRIPT_PATH")/.." && pwd -P)"
RS_CONFIG_DIR="$RS_ROOT_DIR/config"
RS_CACHE_DIR="$RS_ROOT_DIR/cache"
RS_TEMP_DIR="$RS_ROOT_DIR/tmp"

mkdir -p "$RS_CONFIG_DIR" "$RS_CACHE_DIR" "$RS_TEMP_DIR"

# foreground colours
BLACK="$(tput setaf 0)"
RED="$(tput setaf 1)"
GREEN="$(tput setaf 2)"
YELLOW="$(tput setaf 3)"
BLUE="$(tput setaf 4)"
MAGENTA="$(tput setaf 5)"
CYAN="$(tput setaf 6)"
WHITE="$(tput setaf 7)"

# background colours
BLACK_BG="$(tput setab 0)"
RED_BG="$(tput setab 1)"
GREEN_BG="$(tput setab 2)"
YELLOW_BG="$(tput setab 3)"
BLUE_BG="$(tput setab 4)"
MAGENTA_BG="$(tput setab 5)"
CYAN_BG="$(tput setab 6)"
WHITE_BG="$(tput setab 7)"

# other "formatting"
BOLD="$(tput bold)"
UNDERLINE="$(tput smul)"
NO_UNDERLINE="$(tput rmul)"
STANDOUT="$(tput smso)"
NO_STANDOUT="$(tput rmso)"
NO_WRAP="$(tput rmam)"
WRAP="$(tput smam)"
RESET="$(tput sgr0)"

IS_MACOS=0
IS_LINUX=0
IS_UBUNTU=0
IS_SERVER=0
IS_ELEMENTARY_OS=0
IS_PURE_LINUX=0
IS_WSL=0
PLATFORM=

case "$(uname -s)" in

Darwin)

    IS_MACOS=1
    PLATFORM=mac

    ;;

Linux)

    IS_LINUX=1

    if [ -e /proc/version ] && grep -q Microsoft /proc/version; then

        IS_WSL=1
        PLATFORM=wsl

    else

        IS_PURE_LINUX=1
        PLATFORM=linux

    fi

    command_exists X || IS_SERVER=1

    if command_exists lsb_release; then

        DISTRIB_ID="$(lsb_release -si)"
        LSB_RELEASE_EXTRA=

        if [[ "$DISTRIB_ID" == elementary* ]]; then

            DISTRIB_ID="$(lsb_release -siu)"
            LSB_RELEASE_EXTRA=u
            IS_ELEMENTARY_OS=1

        fi

        if [ "$DISTRIB_ID" = "Ubuntu" ]; then

            IS_UBUNTU=1

        fi

        DISTRIB_RELEASE="$(lsb_release -sr$LSB_RELEASE_EXTRA)"
        DISTRIB_CODENAME="$(lsb_release -sc$LSB_RELEASE_EXTRA)"
        DISTRIB_DESCRIPTION="$(lsb_release -sd$LSB_RELEASE_EXTRA)"

    fi

    IS_APT_INSTALLED=1
    IS_SNAP_INSTALLED=1

    { command_exists apt-get && command_exists dpkg; } || IS_APT_INSTALLED=0
    command_exists snap || IS_SNAP_INSTALLED=0

    ;;

*)

    die "Error: unknown platform"

    ;;

esac
