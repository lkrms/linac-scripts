#!/bin/bash
# shellcheck disable=SC1090,SC2015,SC2034,SC2119,SC2120,SC2162

set -euo pipefail

function is_virtual() {

    assert_is_linux

    grep -Eq '^flags\s*:.*\shypervisor(\s|$)' /proc/cpuinfo

}

function is_desktop() {

    assert_is_linux

    local CHASSIS_TYPE PORTABLE_CHASSIS_TYPES=(

        # Portable
        8

        # Laptop
        9

        # Notebook
        10

        # Hand Held
        11

        # Sub Notebook
        14

    )

    CHASSIS_TYPE="$(</sys/class/dmi/id/chassis_type)" || die

    [ -n "$CHASSIS_TYPE" ] || die "No chassis type"

    ! printf '%s\n' "${PORTABLE_CHASSIS_TYPES[@]}" | grep "^${CHASSIS_TYPE}\$" >/dev/null

}

function is_lid_closed() {

    assert_is_linux

    grep -q 'closed$' /proc/acpi/button/lid/*/state

}

function assert_is_macos() {
    lk_is_macos || lk_die "macOS required"
}

function is_macos() {
    lk_is_macos
}

function assert_is_windows() {
    lk_is_wsl || lk_die "Windows required"
}

function is_windows() {
    lk_is_wsl
}

function assert_is_linux() {
    lk_is_linux || lk_die "Linux required"
}

function is_linux() {
    lk_is_linux
}

function assert_is_ubuntu() {
    lk_is_ubuntu || lk_die "Ubuntu required"
}

function is_ubuntu() {
    lk_is_ubuntu
}

function assert_is_desktop() {
    lk_is_macos || lk_command_exists X || lk_die "desktop required"
}

function assert_is_server() {
    ! { lk_is_macos || lk_command_exists X; } || lk_die "server required"
}

function assert_is_ubuntu_lts() {
    lk_is_ubuntu_lts || lk_die "Ubuntu LTS required"
}

function is_ubuntu_lts() {
    lk_is_ubuntu_lts
}

function assert_root() {
    lk_is_root || lk_die "not running as superuser"
}

function assert_not_root() {
    ! lk_is_root || lk_die "running as superuser"
}

function assert_command_exists() {
    lk_command_exists "$@" || lk_die "$*: $(lk_maybe_plural "$#" "command" "one or more commands") not found"
}

function assert_variable_exists() {
    variable_exists "$1" || lk_die "$1: variable not defined"
}

function is_root() {
    lk_is_root
}

# Usage: filename_maybe_add_extension "/path/to/file" ".pdf"
# (output would be "/path/to/file.ext.pdf")
function filename_maybe_add_extension() {

    local FILENAME BASENAME

    FILENAME="$1"
    BASENAME="$(basename "$1")" || die

    [[ "$BASENAME" =~ .+\..+ ]] && [ "$(lower ".${1##*.}")" = "$(lower "$2")" ] || FILENAME="${1}${2}"

    echo "$FILENAME"

}

function filename_add_suffix() {
    lk_add_file_suffix "$@"
}

# filename_get_next_backup: filename_get_next_backup filename [backup-identifier]
function filename_get_next_backup() {

    local i=0 BACKUP_PATH

    BACKUP_PATH="$(filename_add_suffix "$1" "${2:+_$2}_backup")"

    while [ -e "$BACKUP_PATH" ]; do

        BACKUP_PATH="$(filename_add_suffix "$1" "${2:+_$2}_$((++i))_backup")"

    done

    echo "$BACKUP_PATH"

}

function file_mime_type() {

    [ -f "$1" ] || die "$1 isn't a file"

    file -b --mime-type "$1" || die

}

function is_pdf() {

    local MIME_TYPE

    MIME_TYPE="$(file_mime_type "$1")" || die
    [ "$MIME_TYPE" = "application/pdf" ]

}

# returns non-zero if any of the arguments aren't directories
function are_directories() {

    local DIR

    for DIR in "$@"; do

        [ -d "$DIR" ] || return

    done

    return

}

# returns non-zero if any of the arguments aren't files
function are_files() {

    local FILE

    for FILE in "$@"; do

        [ -f "$FILE" ] || return

    done

    return

}

function command_exists() {
    lk_command_exists "$@"
}

function variable_exists() {
    lk_is_identifier "$1" && lk_variable_set "$1"
}

function user_exists() {

    id "$1" >/dev/null 2>&1

}

function is_bool() {

    [[ "$1" =~ ^(true|false)$ ]]

}

function is_int() {

    [[ "$1" =~ ^[0-9]+$ ]]

}

function is_url() {

    # TODO: replace with uri_get_parts regex
    gnu_grep -Pq '\b(([\w-]+://?|www[.])[^\s()<>]+(?:\([\w\d]+\)|([^[:punct:]\s]|/)))' <<<"$1"

}

function echoc() {
    lk_echoc "$@"
}

function die() {
    lk_die "$@"
}

function die_happy() {
    LK_DIE_HAPPY=1 lk_die "$@"
}

function version_at_least() {
    lk_version_at_least "$@"
}

function pause() {
    lk_pause "$@"
}

# console_message: console_message message [entity_list [colour_sequence ...] ]
#
# Output MESSAGE on the standard output, followed by a list of entities.
# Apply colour control sequences to improve readability.
#
# Output is one of the following:
#
# multiple entities
#     >
#     > ==> MESSAGE:
#     > ENTITIES...
#     >
#
# one entity
#     ==> MESSAGE: ENTITY
#
# no entities
#     ==> MESSAGE
#
# On interactive terminals, MESSAGE is bold and colour control sequences
# are applied to "==>", entities, and any MESSAGE text surrounded by
# __double underscores__.
#
# If MESSAGE contains a trailing colon, it is removed. Entities are
# piped to `column`.
#
function console_message() {

    local MESSAGE1 MESSAGE2 MESSAGE2_COUNT OUTPUT

    MESSAGE1="${1%:}"
    MESSAGE2=(${2:-})
    shift || die
    shift || true

    MESSAGE2_COUNT="${#MESSAGE2[@]}"

    [ "$MESSAGE2_COUNT" -eq "0" ] || MESSAGE1="${MESSAGE1}:"

    OUTPUT=$(

        echoc -n "==> " "$@"
        echoc -n "$MESSAGE1" "$BOLD"

        # case statements don't parse in Bash 3.2.57 subshells
        if [ "$MESSAGE2_COUNT" -eq "0" ]; then

            :

        elif [ "$MESSAGE2_COUNT" -eq "1" ]; then

            echoc " ${MESSAGE2[0]}" "$@"

        else

            echo
            echoc "$(printf '%s\n' "${MESSAGE2[@]}" | column)" "$@"

        fi

    )

    if [ "$MESSAGE2_COUNT" -gt "1" ]; then

        printf '\n%s\n\n' "$OUTPUT"

    else

        echo "$OUTPUT"

    fi

}

function console_warning() {

    console_message "$@" >&2

}

function get_value() {

    local PROMPT=() DEFAULT="${2:-}" VALUE

    PROMPT+=("$1")

    [ -z "$DEFAULT" ] || PROMPT+=("[$DEFAULT]")

    read -rp "${PROMPT[*]} " VALUE

    [ -n "$VALUE" ] || VALUE="$DEFAULT"

    echo "$VALUE"

}

# Usage: get_confirmation "Do this?" [default response (y/n)] [force valid response? (y/N)] && { do_it; }
function get_confirmation() {

    local PROMPT=() DEFAULT="${2:-}" FORCE="${3:-N}" YN

    [ -z "$1" ] || PROMPT+=("$1")

    case "$DEFAULT" in

    Y)
        PROMPT+=("[Y/n]")
        ;;

    N)
        PROMPT+=("[y/N]")
        ;;

    *)
        PROMPT+=("[y/n]")
        DEFAULT=
        ;;

    esac

    while :; do

        read -rp "${PROMPT[*]} " YN

        [ -n "$YN" ] || YN="$DEFAULT"

        YN="$(upper "$YN")"

        if [ "$FORCE" != "Y" ] || [[ "$YN" =~ ^(Y|YES|N|NO)$ ]]; then

            break

        fi

    done

    [[ "$YN" =~ ^(Y|YES)$ ]]

}

# Usage: file_to_array "/path/to/file" [exclude-pattern...]
#
# If "/path/to/file" doesn't exist, "/path/to/file-default" is tried.
#
# The following are excluded by default:
# - lines that are empty or only contain whitespace: /^\s*$/
# - comments (lines that start with "#" or ";"): /^[#;]/
#
# To include all lines: file_to_array "/path/to/file" ""
function file_to_array() {

    local FILENAME LINE COMMAND=(cat) EXCLUDE=('^\s*$' '^[#;]')

    FILENAME="${1:-}"
    [ -n "$FILENAME" ] || die "Filename required"
    shift

    if [ "$#" -gt "0" ]; then

        EXCLUDE=("$@")

    fi

    FILE_TO_ARRAY=()
    FILE_TO_ARRAY_FILENAME=

    if [ ! -e "$FILENAME" ]; then

        FILENAME="${FILENAME}-default"

    fi

    if [ -e "$FILENAME" ]; then

        FILE_TO_ARRAY_FILENAME="$(realpath "$FILENAME")" || die

        if [ "${#EXCLUDE[@]}" -gt "1" ] || [ -n "${EXCLUDE[0]}" ]; then

            COMMAND=(grep -Ev "($(array_join_by ")|(" "${EXCLUDE[@]}"))")

        fi

        while IFS= read -r LINE || [ -n "$LINE" ]; do

            FILE_TO_ARRAY+=("$LINE")

        done < <("${COMMAND[@]}" "$FILENAME" || true)

    fi

}

function single_or_plural() {
    lk_maybe_plural "$@"
}

function upper_first() {

    echo "$(echo "$1" | cut -c1 | tr "[:lower:]" "[:upper:]")$(echo "$1" | cut -c2-)"

}

function lower() {

    echo "$1" | tr "[:upper:]" "[:lower:]"

}

function upper() {

    echo "$1" | tr "[:lower:]" "[:upper:]"

}

# Searches the array (must be global, passed by name) for the given value and outputs the first corresponding key if found.
# Plays nicely with globs and sparse arrays. Outputs nothing and exits non-zero if the value isn't found.
#
# Usage: array_search "needle" HAYSTACK_NAME [allow globbing? (Y/n)]
function array_search() {

    local GLOBBING="${3:-Y}" KEYS VALUE i

    eval "KEYS=\"\${!$2[@]}\""

    # two loops = faster than testing GLOBBING inside the loop
    if [ "$GLOBBING" = "Y" ]; then

        for i in $KEYS; do

            eval "VALUE=\"\${$2[$i]}\""

            # shellcheck disable=SC2053
            if [[ "$1" == $VALUE ]] || [[ "$VALUE" == $1 ]]; then

                echo "$i"
                return

            fi

        done

    else

        for i in $KEYS; do

            eval "VALUE=\"\${$2[$i]}\""

            if [ "$1" = "$VALUE" ]; then

                echo "$i"
                return

            fi

        done

    fi

    return 1

}

# Usage: in_array "needle" HAYSTACK_NAME [allow globbing? (y/N)]
function in_array() {

    array_search "$1" "$2" "${3:-N}" >/dev/null

}

# Usage: array_join_by ":" "${MY_ARRAY[@]}"
function array_join_by() {

    local SEP ARR

    SEP="$1"
    shift

    if [ "$#" -gt "0" ]; then

        ARR=("${@/#/$SEP}")
        ARR[0]="$1"
        printf '%s' "${ARR[@]}"

    fi

}

# Usage: array_join_oxford "${MY_ARRAY[@]}"
function array_join_oxford() {

    local THREE_OR_MORE=0

    echo -n "${1:-}"
    shift

    while [ "$#" -gt "1" ]; do

        THREE_OR_MORE=1
        echo -n ", $1"
        shift

    done

    [ "$THREE_OR_MORE" -eq "0" ] || echo -n ','
    [ "$#" -eq "0" ] || echo -n " and $1"

}

# Usage: sort_words "these words need sorting"
# (output would be "need sorting these words")
function sort_words() {

    local WORDS

    WORDS=(${1:-})

    [ "${#WORDS[@]}" -eq "0" ] || {
        WORDS=($(printf '%s\n' "${WORDS[@]}" | sort | uniq))
        echo "${WORDS[*]}"
    }

}

function has_argument() {

    in_array "$1" ORIGINAL_ARGUMENTS

}

function is_autostart() {

    has_argument "--autostart"

}

function offer_sudo_password_bypass() {
    local CHECK_FILENAME FILENAME
    lk_user_in_group "$USER" admin sudo wheel || return
    CHECK_FILENAME="$CACHE_DIR/.nopasswd-$USER"
    [ ! -e "$CHECK_FILENAME" ] || ! sudo -n true 2>/dev/null || return 0
    FILENAME="/etc/sudoers.d/nopasswd-$USER"
    sudo -n true 2>/dev/null || lk_console_message "Please enter your computer password if requested"
    sudo true || return
    sudo test -e "$FILENAME" ||
        ! get_confirmation "Allow user $USER to skip future password prompts from sudo?" Y Y || {
        sudo tee "$FILENAME" >/dev/null <<<"$USER ALL=(ALL) NOPASSWD:ALL" &&
            sudo chmod 440 "$FILENAME" &&
            lk_console_message "Password bypass enabled for $USER"
    } || return
    touch "$CHECK_FILENAME" 2>/dev/null || sudo touch "$CHECK_FILENAME" 2>/dev/null || true
}

function escape_separators() {

    local ARG

    ARG="$1" || die

    ARG="${ARG// /\\ }"
    ARG="${ARG//$'\t'/$'\\\t'}"
    ARG="${ARG//$'\n'/$'\\\n'}"

    printf '%s' "$ARG"

}

# Usage: sed_escape_search "text to escape" [extended regular expressions? (Y/n)]
function sed_escape_search() {

    local ESCAPE EXTENDED="${2:-Y}"

    ESCAPE="$1" || die

    if [ "$EXTENDED" != "N" ]; then

        # shellcheck disable=SC2016
        gnu_sed 's/[]$()*+./?\^{|}[]/\\&/g' <<<"$ESCAPE"

    else

        gnu_sed 's/[]$*./\^[]/\\&/g' <<<"$ESCAPE"

    fi

}

function sed_escape_replace() {

    local ESCAPE ESCAPED

    ESCAPE="$1" || die

    ESCAPED="$(gnu_sed 's/[\/&]/\\&/g' <<<"$ESCAPE")"
    printf '%s' "${ESCAPED//$'\n'/\\n}"

}

# Usage: search_replace "find" "replace with" "string"
function search_replace() {
    lk_replace "$@"
}

function date_get_log() {

    date +'%b %_d %H:%M:%S %z'

}

function date_get_log_nano() {

    gnu_date +'%b %_d %H:%M:%S.%N %z'

}

function date_get_ymdhms() {

    date +'%Y%m%d%H%M%S'

}

function date_get_timestamp() {

    date +'%s'

}

function url_decode() {

    echo -e "${*//%/\\x}"

}

# Results are returned in document order without de-duplication.
#
# Usage: get_urls_from_url "http://url.to/page-with-urls" [regex to limit results...]
function get_urls_from_url() {

    local TEMP_FILE URLS PATTERN

    TEMP_FILE="$(create_temp_file)"

    wget --quiet --convert-links --output-document "$TEMP_FILE" "$1" || {
        rm -f "$TEMP_FILE" || true
        die
    }

    shift

    # `scheme:` is required (otherwise pretty much everything would be a 'URL')
    URLS="$(grep -Eo '\b(([a-zA-Z][-a-zA-Z0-9+.]*):)(//(([-a-zA-Z0-9._~%!$&'"'"'()*+,;=]+)(:([-a-zA-Z0-9._~%!$&'"'"'()*+,;=]*))?@)?([-a-zA-Z0-9._~%!$&'"'"'()*+,;=]+|\[([0-9a-fA-F:]+)\])(:([0-9]+))?)?([-a-zA-Z0-9._~%!$&'"'"'()*+,;=:@/]+)?(\?([-a-zA-Z0-9._~%!$&'"'"'()*+,;=:@?/]+))?(#([-a-zA-Z0-9._~%!$&'"'"'()*+,;=:@?/]*))?\b' "$TEMP_FILE")" || true

    rm -f "$TEMP_FILE"

    for PATTERN in "$@"; do

        URLS="$(echo "$URLS" | grep -E "$PATTERN")" || true

    done

    echo "$URLS"

}

# Usage: uri_get_parts "any://valid.uri?with=any#parts" <scheme|username|password|host|ipv6_address|port|path|query|fragment...>
# See: https://en.wikipedia.org/wiki/Uniform_Resource_Identifier
function uri_get_parts() {

    local URI="$1" FMT=() EXPR=() PART

    shift

    for PART in "$@"; do

        FMT+=("%s")

        case "$PART" in

        scheme)
            EXPR+=("a[2]")
            ;;

        username)
            EXPR+=("a[5]")
            ;;

        password)
            EXPR+=("a[7]")
            ;;

        host)
            # with brackets if IPv6 address
            EXPR+=("a[8]")
            ;;

        ipv6_address)
            EXPR+=("a[9]")
            ;;

        port)
            EXPR+=("a[11]")
            ;;

        path)
            EXPR+=("a[12]")
            ;;

        query)
            EXPR+=("a[14]")
            ;;

        fragment)
            EXPR+=("a[16]")
            ;;

        *)
            die "Unknown URI component: $PART"
            ;;

        esac

    done

    gnu_awk '{match($0,/^(([a-zA-Z][-a-zA-Z0-9+.]*):)?(\/\/(([-a-zA-Z0-9._~%!$&'"'"'()*+,;=]+)(:([-a-zA-Z0-9._~%!$&'"'"'()*+,;=]*))?@)?([-a-zA-Z0-9._~%!$&'"'"'()*+,;=]+|\[([0-9a-fA-F:]+)\])(:([0-9]+))?)?([-a-zA-Z0-9._~%!$&'"'"'()*+,;=:@/]+)?(\?([-a-zA-Z0-9._~%!$&'"'"'()*+,;=:@?/]+))?(#([-a-zA-Z0-9._~%!$&'"'"'()*+,;=:@?/]*))?$/,a);printf "'"$(array_join_by '\n' "${FMT[@]}")"'\n",'"$(array_join_by ',' "${EXPR[@]}")"'}' <<<"$URI"

}

# files are downloaded to the current directory, and local filenames are output
function download_urls() {

    local URL FILENAME HEADERS DOWNLOAD_FAILED=0 ERROR_MESSAGE HEADER IFS HEADER_PARTS i

    for URL in "$@"; do

        FILENAME=
        HEADERS="$(wget --server-response --timestamping --no-verbose "$URL" 2>&1 >/dev/null)" || DOWNLOAD_FAILED=1

        if [ "$DOWNLOAD_FAILED" -eq "1" ]; then

            ERROR_MESSAGE="Unable to download ($(echo "$HEADERS" | head -n1)): $URL"

            if [ -n "${DOWNLOAD_URLS_SKIP_REGEX:-}" ] && [[ "$(echo "$HEADERS" | head -n1)" =~ $DOWNLOAD_URLS_SKIP_REGEX ]]; then

                echoc "$ERROR_MESSAGE" "$BOLD" "$RED" >&2
                DOWNLOAD_FAILED=0
                continue

            else

                die "$ERROR_MESSAGE"

            fi

        fi

        if HEADER="$(
            echo "$HEADERS" | grep -Ei '^[[:space:]]*Content-Disposition:' | tail -n1 | sed -E 's/(^[[:space:]]*Content-Disposition:)//ig'
        )"; then

            IFS=" ;"
            HEADER_PARTS=($HEADER)
            unset IFS

            for i in "${!HEADER_PARTS[@]}"; do

                HEADER="${HEADER_PARTS[$i]}"

                if FILENAME="$(
                    echo "$HEADER" | gnu_grep -Pio '(?<=^filename=).*' | sed -E 's/^[[:space:]]*("?)(.*)\1[[:space:]]*$/\2/g'
                )"; then

                    break

                else

                    FILENAME=

                fi

            done

        fi

        if [ -z "$FILENAME" ] || [ ! -e "$FILENAME" ]; then

            FILENAME="$(url_decode "$URL")"
            FILENAME="${FILENAME##*/}"

        fi

        # TODO: use the final "Location:" header to make an additional filename guess
        # (this should mean wget's --content-disposition option can be used safely)
        if [ ! -e "$FILENAME" ]; then

            die "Unable to determine filename for $URL"

        fi

        echo "$PWD/$FILENAME"

        echoc "Finished downloading $URL" "$CYAN" >&2

    done

}

# get_log_file [suffix]
#   Outputs the path to a writable log file based on the name of the
#   running script and the current user's effective ID.
#
function get_log_file() {

    local LOG_ROOTS LOG_ROOT LOG_BASENAME LOG_PATH

    LOG_ROOTS=(
        "$LOG_DIR"
        ~/.local/var/log
        ~
        /tmp
    )

    LOG_BASENAME="$(basename "$0")${1:-}.$EUID.log"

    for LOG_ROOT in "${LOG_ROOTS[@]}"; do

        [ -d "$LOG_ROOT" ] ||
            { [ ! -e "$LOG_ROOT" ] && mkdir -p "$LOG_ROOT" 2>/dev/null; } ||
            continue

        [ -w "$LOG_ROOT" ] || continue

        LOG_PATH="$LOG_ROOT/$LOG_BASENAME"

        [ -f "$LOG_PATH" ] || [ ! -e "$LOG_PATH" ] || continue

        touch "$LOG_PATH" 2>/dev/null || continue

        echo "$LOG_PATH"
        return

    done

    die "No writable log file location"

}

# start_or_restart [/path/to/]command [arg ...]
#   Kill any running COMMAND processes, then run COMMAND in the
#   background and disown it.
#
function start_or_restart() {

    local COMMAND LOG_FILE LOG_FILE2 LOG_MESSAGE

    COMMAND="$(basename "$1")" || die
    LOG_FILE="$(get_log_file "_$COMMAND.stdout")" || die
    LOG_FILE2="$(get_log_file "_$COMMAND.stderr")" || die

    # limit to processes owned by $USER unless running as root
    is_root || ! pgrep -xu "$USER" "$COMMAND" >/dev/null || echo_run pkill -xu "$USER" "$COMMAND"
    ! is_root || ! pgrep -x "$COMMAND" >/dev/null || echo_run pkill -x "$COMMAND"

    if command_exists "$1"; then

        LOG_MESSAGE="$(date_get_log) [${FUNCNAME[0]}] Running: $*"
        echo $'\n'"$LOG_MESSAGE" >>"$LOG_FILE"
        echo $'\n'"$LOG_MESSAGE" >>"$LOG_FILE2"
        nohup "$@" </dev/null >>"$LOG_FILE" 2>&1 &
        disown

    fi

}

function time_command() {

    local EXIT_CODE=0

    exec 8>&1 9>&2 || die
    COMMAND_TIME="$(
        TIMEFORMAT="${TIMEFORMAT:-%3lR}"
        { time "$@" 1>&8 2>&9; } 2>&1
    )" || EXIT_CODE="$?"
    exec 8>&- 9>&-

    return "$EXIT_CODE"

}

function maybe_sudo() {
    lk_maybe_sudo "$@"
}

# Usage: echo_run command [arg1...]
function echo_run() {

    local EXTRA_NEWLINE="\n" ARG ARGS=() EXIT_CODE="0" EXIT_COLOR="${GREEN}"

    [ -t 1 ] || EXTRA_NEWLINE=

    for ARG in "$@"; do

        ARGS+=("$(escape_separators "$ARG")")

    done

    printf "${GREY}[%s] ${BOLD}${CYAN}Running command:${RESET}%s\n${EXTRA_NEWLINE}" "$(date_get_log)" "$(printf ' %s' "${ARGS[@]}")" >&2

    time_command "$@" || {
        EXIT_CODE="$?"
        EXIT_COLOR="${RED}"
    }

    [ "${ECHO_RUN_EXIT_MESSAGE:-N}" = "N" ] && [ "$EXIT_CODE" -eq "0" ] || printf "${EXTRA_NEWLINE}${GREY}[%s] ${BOLD}${EXIT_COLOR}Exit code:${RESET} %s ${GREY}(after %s)${RESET}\n${EXTRA_NEWLINE}" "$(date_get_log)" "$EXIT_CODE" "$COMMAND_TIME" >&2

    return "$EXIT_CODE"

}

function safe_symlink() {
    lk_safe_symlink "$@"
}

# Usage: safe_sed /path/to/file sed_command1 [sed_command2...]
function safe_sed() {

    local FILENAME COMMAND COMMANDS=() CHANGED

    FILENAME="$1" || die
    shift

    [ -f "$FILENAME" ] || die "File doesn't exist: $FILENAME"

    for COMMAND in "$@"; do

        COMMANDS+=(-e "$COMMAND")

    done

    CHANGED="$(gnu_sed -E "${COMMANDS[@]}" "$FILENAME")" || die

    if ! diff -q ".git/config" <(printf '%s' "$CHANGED") >/dev/null; then

        printf '%s' "$CHANGED" >"$FILENAME" || die

    fi

}

function is_dryrun() {

    [ "$ORIGINAL_DRYRUN_ARGUMENT" = "--dryrun" ] || { [ "${DRYRUN_BY_DEFAULT:-N}" != "N" ] && [ "$ORIGINAL_DRYRUN_ARGUMENT" != "--run" ]; }

}

function dryrun_message() {

    local EXTRA=

    if is_dryrun; then

        [ "${DRYRUN_BY_DEFAULT:-N}" = "N" ] || EXTRA=" (use \"--run\" as the first argument to override)"

        lk_console_message "$(basename "$0") is in dry run mode${EXTRA}" "$BOLD$RED" >&2

    fi

}

# Usage: maybe_dryrun command [argument1...]
function maybe_dryrun() {

    if is_dryrun; then

        lk_console_item "Command skipped (dry run):" "$*" "$YELLOW" >&2

    else

        "$@"

    fi

}

# Usage: create_temp_file [use $TEMP_DIR? (y/N)]
function create_temp_file() {

    local TEMP_ROOT="/tmp" TEMP_PATH

    [ "${1:-N}" = "N" ] || TEMP_ROOT="$TEMP_DIR"

    TEMP_PATH="$(mktemp "$TEMP_ROOT/$(basename "$0").$(date_get_timestamp).XXXXXXXX")" ||
        die "Unable to create temporary file"

    echo "$TEMP_PATH"

}

# Usage: create_temp_dir [use $TEMP_DIR? (y/N)]
function create_temp_dir() {

    local TEMP_ROOT="/tmp" TEMP_PATH

    [ "${1:-N}" = "N" ] || TEMP_ROOT="$TEMP_DIR"

    TEMP_PATH="$(mktemp -d "$TEMP_ROOT/$(basename "$0").$(date_get_timestamp).XXXXXXXX")" ||
        die "Unable to create temporary directory"

    echo "$TEMP_PATH"

}

# Usage: create_temp_fifo [use $TEMP_DIR? (y/N)]
function create_temp_fifo() {

    local FIFO_DIR FIFO_PATH

    FIFO_PATH="$(create_temp_dir "$@")/fifo"
    mkfifo "$FIFO_PATH" ||
        die "Unable to create temporary FIFO"

    echo "$FIFO_PATH"

}

function flush_fifo() {

    dd if="$1" iflag=nonblock of=/dev/null

}

function get_x_displays() {

    assert_is_desktop

    local X

    if [ -d /tmp/.X11-unix ]; then

        for X in /tmp/.X11-unix/X*; do

            echo ":${X##*X}"

        done

    fi

}

function dir_make_and_own() {

    assert_not_root

    [ -d "$1" ] || sudo mkdir -p "$1" || die

    [ -w "$1" ] || sudo chown "$(id -un):$(id -gn)" "$1" || die

}

function windows_running_as_administrator() {

    assert_command_exists whoami.exe

    whoami.exe /groups | grep '\bS-1-5-32-544\b.*\bEnabled group\b' >/dev/null

}

# because Bash 3.2 exits when eval exits non-zero, regardless of context or errexit status
function eval_test() {

    local EXIT_CODE

    EXIT_CODE="$(eval 'if' "$@" '; then echo "0"; else echo "1"; fi')"

    return "$EXIT_CODE"

}

function link_settings() {

    local i TO

    assert_command_exists realpath

    APP_NAME="${APP_NAME:-app}"

    if [ -n "${COMMAND_CHECK:-}" ]; then

        if ! command_exists "$COMMAND_CHECK"; then

            die "$APP_NAME isn't installed (command doesn't exist: $COMMAND_CHECK)"

        fi

    fi

    if [ -n "${RUNNING_CHECK:-}" ]; then

        if eval_test "$RUNNING_CHECK"; then

            die "$APP_NAME is currently running"

        fi

    fi

    if [ -n "${DIRECTORY_CHECK:-}" ]; then

        if [ ! -d "$DIRECTORY_CHECK" ]; then

            die "$DIRECTORY_CHECK doesn't exist (have you run $APP_NAME yet?)"

        fi

    fi

    if is_windows && ! windows_running_as_administrator; then

        die "$(basename "$0") must be run as administrator for symbolic links to work"

    fi

    console_message "Linking settings files for $APP_NAME" "" "$BOLD" "$CYAN"

    for i in "${!LINK_FROM[@]}"; do

        [ -e "${LINK_TO[$i]}" ] || {
            console_warning "Can't link to missing file ${LINK_TO[$i]}" "" "$BOLD" "$RED"
            continue
        }

        TO="$(realpath "${LINK_TO[$i]}")" || die
        safe_symlink "$TO" "${LINK_FROM[$i]}"

    done

}

function array_filter_platform() {

    printf '%s\n' "$@" | gnu_grep -Po "^[^:]+(?=(:([^:|]+\|)*$PLATFORM(\|[^:|]+)*)?\$)" || true

}

# Usage: install_or_queue "Description of this group" "item1 item2 ..." <allow user override? (y/n)> <singular noun> <plural noun> <name of "installed items" array> <name of "available items" array> <name of "to install" array to fill> [name of "already installed" array to fill]
function install_or_queue() {

    local REQUESTED=($2) UI="$3" SINGLE="$4" PLURAL="$5" ITEMS_INSTALLED ITEMS_AVAILABLE INSTALL_TARGET="$8" ALREADY_INSTALLED_TARGET="${9:-}"

    console_message "Checking ${BOLD}${1}${RESET} $PLURAL" "" "$CYAN"

    local i=6 j k
    for j in ITEMS_INSTALLED ITEMS_AVAILABLE; do

        # k="$6"
        eval 'k="$'"$i"'"'

        if [ -z "$k" ]; then

            eval "$j"'=()'

        elif variable_exists "$k"; then

            # ITEMS_INSTALLED=($(printf '%s\n' "${NAME_OF_ARRAY[@]}" | sort | uniq))
            eval "$j"'=($(printf '"'"'%s\n'"'"' "${'"$k"'[@]}" | sort | uniq))'

        else

            # ITEMS_INSTALLED=($(COMMAND | sort | uniq)) || true
            eval "$j"'=($('"$k"' | sort | uniq)) || true'

        fi

        ((i += 1))

    done

    local IOQ_INSTALL IOQ_UNAVAILABLE IOQ_ALREADY_INSTALLED

    IOQ_INSTALL=($(comm -23 <(printf '%s\n' "${REQUESTED[@]}" | sort | uniq) <([ "${#ITEMS_INSTALLED[@]}" -gt "0" ] && printf '%s\n' "${ITEMS_INSTALLED[@]}" || true)))
    IOQ_ALREADY_INSTALLED=($(comm -12 <(printf '%s\n' "${REQUESTED[@]}" | sort | uniq) <([ "${#ITEMS_INSTALLED[@]}" -gt "0" ] && printf '%s\n' "${ITEMS_INSTALLED[@]}" || true)))

    if [ "${#IOQ_ALREADY_INSTALLED[@]}" -gt "0" ] && [ -n "$ALREADY_INSTALLED_TARGET" ]; then

        eval "$ALREADY_INSTALLED_TARGET"'+=("${IOQ_ALREADY_INSTALLED[@]}")'

    fi

    if [ "${#IOQ_INSTALL[@]}" -gt "0" ]; then

        if [ "${#ITEMS_AVAILABLE[@]}" -gt "0" ]; then

            IOQ_UNAVAILABLE=($(comm -23 <(printf '%s\n' "${IOQ_INSTALL[@]}" | sort | uniq) <(printf '%s\n' "${ITEMS_AVAILABLE[@]}")))

            if [ "${#IOQ_UNAVAILABLE[@]}" -gt "0" ]; then

                console_message "${#IOQ_UNAVAILABLE[@]} $(single_or_plural "${#IOQ_UNAVAILABLE[@]}" "$SINGLE" "$PLURAL") unavailable for installation:" "${IOQ_UNAVAILABLE[*]}" "$BOLD" "$RED"

                IOQ_INSTALL=($(comm -12 <(printf '%s\n' "${IOQ_INSTALL[@]}" | sort | uniq) <(printf '%s\n' "${ITEMS_AVAILABLE[@]}")))

                [ "${#IOQ_INSTALL[@]}" -gt "0" ] || return 0

            fi

        fi

        if [ "$UI" = "Y" ]; then

            console_message "Missing ${#IOQ_INSTALL[@]} $1 $(single_or_plural "${#IOQ_INSTALL[@]}" "$SINGLE" "$PLURAL"):" "${IOQ_INSTALL[*]}" "$BOLD" "$MAGENTA"

            get_confirmation "Add the $1 $(single_or_plural "${#IOQ_INSTALL[@]}" "$SINGLE" "$PLURAL") listed above?" Y Y || return 0

        else

            console_message "Adding ${#IOQ_INSTALL[@]} $1 $(single_or_plural "${#IOQ_INSTALL[@]}" "$SINGLE" "$PLURAL"):" "${IOQ_INSTALL[*]}" "$GREEN"

        fi

        if variable_exists "$INSTALL_TARGET"; then

            eval "$INSTALL_TARGET"'+=("${IOQ_INSTALL[@]}")'

        else

            # shellcheck disable=SC2086
            eval $INSTALL_TARGET "${IOQ_INSTALL[@]}"

        fi

    fi

}

# Usage: test_host_port my.host.address port-number
function test_host_port() {

    # 1-second timeout -- intended for LAN service availability checks
    gnu_nc -zw 1 "$1" "$2" >/dev/null 2>&1

}

# outputs the installed memory size in MiB
function get_memory_size() {

    local MEMSIZE

    if is_linux; then

        assert_command_exists dmidecode

        sudo dmidecode -t memory | sed -E 's/^\s+(.*)$/\1/' | gnu_grep -Po '(?<=^Size: )[0-9]+(?= MB$)' | awk '{ram+=$1} END {print ram}' || die

    elif is_macos; then

        MEMSIZE="$(sysctl -n hw.memsize)" || die
        echo "$((MEMSIZE / 1024 ** 2))"

    else

        die "Unable to determine memory size on this platform"

    fi
}

COMMON_SCRIPT_PATH="$(realpath "${BASH_SOURCE[0]}" 2>/dev/null)" || COMMON_SCRIPT_PATH="$(python -c 'import os,sys;print os.path.realpath(sys.argv[1])' "${BASH_SOURCE[0]}")"
ROOT_DIR_RELATIVE="$(dirname "$COMMON_SCRIPT_PATH")/.."
ROOT_DIR="$(realpath "$ROOT_DIR_RELATIVE" 2>/dev/null)" || ROOT_DIR="$(python -c 'import os,sys;print os.path.realpath(sys.argv[1])' "$ROOT_DIR_RELATIVE")"

. "$ROOT_DIR/bash/common-functions"

lk_trap_err

CONFIG_DIR="$ROOT_DIR/config"
CACHE_DIR="$ROOT_DIR/cache"
LOG_DIR="$ROOT_DIR/log"
TEMP_DIR="$ROOT_DIR/tmp"

FONTPATH=

shopt -s expand_aliases
alias pop_return1='{ popd >/dev/null; return 1; }'
alias basename='basename --'

ORIGINAL_DRYRUN_ARGUMENT=

if [[ "${1:-}" =~ --(dry)?run ]]; then

    ORIGINAL_DRYRUN_ARGUMENT="$1"
    shift

fi

ORIGINAL_ARGUMENTS=("$@")

mkdir -p "$CONFIG_DIR" "$CACHE_DIR" "$LOG_DIR" "$TEMP_DIR"

eval "$(lk_get_colours '')"

if lk_is_macos; then
    PLATFORM=mac
    FONTPATH="${HOME:+$HOME/Library/Fonts:}/Library/Fonts"
    . "$ROOT_DIR/bash/common-macos"
elif lk_is_linux; then
    if lk_is_wsl; then
        PLATFORM=wsl
        FONTPATH="/mnt/c/Windows/Fonts:${HOME:+$HOME/.local/share/fonts:}/usr/share/fonts"
    else
        PLATFORM=linux
        FONTPATH="${HOME:+$HOME/.local/share/fonts:}/usr/share/fonts"
    fi
    [ -f /etc/lsb-release ] && . /etc/lsb-release
    . "$ROOT_DIR/bash/common-linux"
else
    die "unknown platform"
fi

[ ! -e "$CONFIG_DIR/settings" ] || . "$CONFIG_DIR/settings"
